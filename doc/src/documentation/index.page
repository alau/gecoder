---
title: Introduction
long_title: Documentation for Gecode/R, a Ruby interface to Gecode
inMenu: true
description: How to use Gecode/R to model problems and solve them using constraint programming.
---
h2. Introduction

When using Gecode/R to solve a problem you first have to model the problem by
expressing what a solution to the problem is. Once the problem is modelled the
underlying engine will search for a solution.

A model is typically constructed by creating a class that inherits from 
@Gecode::Model@.

<ruby>
class MyModel < Gecode::Model
  def initialize
    # Place variables, constraints and branching selection here.
  end
end

# Print the solution.
puts MyModel.new.solve!.to_s
</ruby>

There are three main parts of a model:
* Variables
* Constraints
* Branching

h3. Variables

h4. Integer variables

Integer variables have domains which must be specified upon construction. The 
domain of a variable represents the values that the variable can take, for 
instance a variable might have domain 0..9 which means that it can take any 
value in the range 0 to 9. To create an integer variable we use @Model#int_var@.

<ruby>
number = int_var(0..9) # Creates an integer variable with domain 0..9.
</ruby>

Alternatively one can also create multiple integer variables with the same 
domain at once using @Model#int_var_array@ which returns an array of variables.

<ruby>
numbers = int_var_array(8, 0..9) # Creates 8 variables with domains 0..9.
</ruby>

The domain specified does not have to be a range, it can also be an enumeration
of elements. The following creates an integer variable with the odd numbers in 
0..9 as domain.

<ruby>
odd_number = int_var([1,3,5,7,9])
</ruby>

Matrices can be created using @Model#int_var_matrix@ (returns an instance of
Matrix). 

<ruby>
number_matrix = int_var_matrix(5, 4, 0..9) # 5 rows and 4 columns.
</ruby>

Additional custom enumerations containing variables can be used, but they have
to be wrapped using @Model#wrap_enum@ first.

<ruby>
my_enum = wrap_enum(my_enum)
my_enum.must_be.distinct
</ruby>

h4. Boolean variables

Boolean variables (which can either be true or false) are created using 
@Model#bool_var@, @Model#bool_var_array@ and @Model#bool_var_matrix@, just like 
integer variables but without the need for domains.

<ruby>
bool = bool_var # Creates a boolean variable
bools = bool_var_array(3) # Creates 3 boolean variables.
bool_matrix = bool_var_matrix(3, 4) # Creates a 3x4 matrix of boolean variables.
</ruby>

h4. Set variables

Set variables are created using @Model#set_var@, @Model#set_var_array@ and 
@Model#set_var_matrix@. Set variables represent sets, the domain that can be 
specified for them are the greatest lower bound (GLB), least upper bound (LUB)
and cardinality (which is optional). The bounds can be specified using either 
ranges or other enumerations. The cardinality can only be specified with ranges 
or as a single number, which is then used as the minimum cardinality.

The greatest lower bound is the largest set of elements that are certain to be 
in the set, the least upper bound is the smallest set of elements that might be
in the set (which should include the greatest lower bound). I.e. the greatest
lower bound is a subset of the assigned set which is a subset of the least upper
bound.

<ruby>
# Creates a set variable with glb 1..2 and lub 1..6 .
set = set_var(1..2, 1..6) 
# Creates an array of 3 set variables with the above bounds and a minimum 
# cardinality of 3.
sets = set_var_array(3, 1..2, 1..6, 3)
# Creates a 7x9 matrix of set variables with the above bounds and a cardinality 
# between 2 and 5
set_matrix = set_var_matrix(7, 9, 1..2, 1..6 2..5)
</ruby>

h3. Constraints

The constraints specify what must hold for something to be a solution. They are
created using variables in combination with @must@ and @must_not@. The 
constraint that one variable x must be larger than another variable y is for 
instance expressed as

<ruby>
x.must > y
</ruby>

h3. Branching

The solver tries to prune the search space without actually exploring it, but
sooner or later it will probably have to make a guess about a variable's value
in order to get any further (i.e. it will have to explore the search space).
This is called branching. Which variable and selection strategies to use is 
specified with @Model#branch_on@

<ruby>
branch_on numbers, :variable => :smallest_size, :value => :min
</ruby>

One can specify how these guesses should be made, possibly cutting down the
search space by picking a good heuristic. An example of a common heuristic
is first fail, which makes a guess about the variable with the smallest domain 
(i.e. with lowest number of possible values). The reason why this often works
well is that we can quicker exhaust the remaining possibilities of a variable 
with a small domain, and hence force a fail (or a solution to be found) so that
we can backtrack to the next possible choice.

h3. Accessing solutions

h4. Depth first search

The solutions to a model can be accessed by several methods. The simplest case
is when one just want a	single solution to the problem, in which case 
@Model#solve!@ (which destructivly alters the instance of @Model@) is 
convenient.

<ruby>
instance = MyModel.new
solution = instance.solve!
</ruby>

If there are no solutions then @solution@ will be @nil@ (and the instance of the
model will be untouched). If there is a solution then the model instance will
reflect that solution (i.e. all variables accessed through the model instance 
will be the solution's variables) as well as return it to be assigned to 
@solution@.

It's possible to reset the instance back to the original form using 
@Model#reset!@.

<ruby>
instance.reset!
</ruby>

Note that this also resets any solutions returned earlier by @Model#solve!@.

A similar form with blocks if also available through @Model#solution@.

<ruby>
string = instance.solution{ |solution| solution.to_s }
</ruby>

It gives a solution to the block and then returns the result of the block. 
Iterating through all solutions to a problem is done using 
@Model.each_solution@.

<ruby>
instance.each_solution{ |solution| puts solution.to_s }
</ruby>

In both cases the model instance is unaffected after the method-call.

h4. Branch and bound search

Branch and bounds search is used when one is not just looking for _any_ 
solution, but rather the _optimal_ solution (as defined by some criteria). For 
instance we might want to find the solution which assigns the smallest value
to a price variable. This is done by using the @Model#optimize!@ method, which
takes a block with two arguments: the model itself and the best solution found
so far. The block should then add a constraint that constrains the model to be
strictly better than the best solution so far.

<ruby>
optimal_solution = price_model_instance.optimize! do |model, best_so_far|
  model.price.must < best_so_far.price.val
end
</ruby>

This destructively updates @price_model_instance@ to contain the returned 
solution, just like @Model#solve!@. If there is not solution then 
@optimal_solution@ will be assigned @nil@ and @price_model_instance@ will be
unchanged.

h2. Modelling a problem

The following is a brief introduction of how to model problems, using 
"sudoku":http://en.wikipedia.org/wiki/Sudoku as a case study.

h3. Understand the problem

The first step is to understand the problem, more specifically to understand 
what is required of a solution to the problem. In the case of sudoku we just 
need to know the following:

bq. The objective is to fill a 9x9 grid so that each column, each row, and each 
of the nine 3x3 boxes contains the digits from 1 to 9. The puzzle setter 
provides a partially completed grid. - "Wikipedia":http://en.wikipedia.org/wiki/Soduko

This gives us some insight into what we need to express in our model.

h3. Selecting the view

The next step is to select how to represent the problem in terms of variables. 
The variables will need to include the sought solutions. In the case of sudoku
that means that the variables must in some way represent a 9x9 grid where each
cell can be assigned a value in 1..9.

One intuitive choice is to use a 9x9 matrix of integer variables with the 
domains 1..9 as "shown in the sudoku example":../examples/sudoku.html. In terms 
of code it's expressed as

<ruby>
@squares = int_var_matrix(9, 9, 1..9)
</ruby>

h4. Multiple views

There are however other ways to view the problem. For instance we could instead 
choose to use 9 set variables, one for each assignable value. Each set would
then contain a square iff the corresponding value is assigned to the square. 
Meaning that the first set would contain the squares to which 1 is assigned, the
second set would contain the squares to which 2 is assigned and so on. The 
squares could be represented as number ranging from 1 to 81. This view is shown 
in the "sudoku example with sets":../examples/sudoku-set.html .

The point is that there are often multiple ways to view a single problem. Being 
aware of more than one might help further down the line. Constraints might end 
up being hard to describe in one view, but trivial in another.

There's no need to restrict oneself to only using one view. One can link
multiple views using the channel constraint to get the best of both worlds. The
two sudoku views above are examples of two views which can be channeled.

h3. Expressing the constraints

We select the integer variable view. The first thing we notice is that we no 
longer need to worry about 

bq. The objective is to fill a 9x9 grid ... contains the digits from 1 to 9.

because our choice of view already takes care of that. This illustrates another
reason for trying to find multiple views, some might cut down on the number of
constraints that we explicitly have to express. Another example is the "n-queens 
problem":../examples/n-queens.html where the choice of view takes care of the
constraint that there may only be one queen per column. We would not have that
benefit if we for instance would use a nxn matrix of boolean variables.

We are left with the following constraints that still need to be expressed:

# Each column must contain the digits from 1 to 9.
# Each row must contain the digits from 1 to 9.
# Each of the nine 3x3 boxes must contain the digits from 1 to 9.
# The puzzle setter provides a partially completed grid.

Another way to phrase the first three constraints is that the digits in each 
row, column and 3x3 boxes must be distinct, since we have already made sure that
only digits from 1 to 9 are allowed (and that each square must be assigned 
exactly one).

The distinct constraint is a perfect match, so all we need to do to express the
first three constraints is to place a distinct constraint on each row, column
and 3x3 box of our variable matrix. Expressed in code it becomes:

<ruby>
9.times do |i|
  # All rows must contain distinct numbers.
  @squares.row(i).must_be.distinct
  # All columns must contain distinct numbers.
  @squares.column(i).must_be.distinct
  # All 3x3 boxes must contain distinct numbers.
  @squares.minor((i % 3) * 3, 3, (i / 3) * 3, 3).must_be.distinct
end
</ruby>

That leaves us with the fourth constraint. We want to constraint specific 
squares (i.e. integer variables) to only take a specified value, hence an 
integer domain constraint would seem ideal (or alternatively creating each 
variable individually with modified domains). In code we express it as:

<ruby>
predefined_values.row_size.times do |i|
  predefined_values.column_size.times do |j|
    unless predefined_values[i,j].zero?
      @squares[i,j].must == predefined_values[i,j]
    end
  end
end
</ruby>

Where @predefined_values@ is a matrix with the partially completed grid (
containing 0 where nothing is assigned).

h4. Implied constraints

We have now given Gecode all of the sudoku rules, enough for it to be able to
fetch us a solution. That does however not mean that we are out of constraints. 
It might still be worth explicitly expressing some of the constraints that are
implicitly given by our expressed constrained. It will not change the solutions,
but it can help Gecode prune the search space faster.

One such constraint in our case is a constraint linking the squares and the 
rows. It's not necessary, but it will make the search faster.

h3. Tweaking

We have now built and implemented a model for solving the sudoku problem using 
constraint programming, but there's still some tweaking to be considered. 

h4. Branching strategies

Branching strategies can make a large difference. Which is best depends on the
problem. One can reason why some heuristics should fit better than others, but
we can also simply try them all out and see how well they perform.

h4. Propagation strengths

Using different propagation can, much like branching strategies, make a large
difference. Much like branching strategies it's a matter of reasoning or simply
trying them out.

h4. Breaking symmetries

In many situations several situations symmetries might appear. In the 
"n-queens example":../example/n-queens.html we have several rotational and 
reflection symmetries since the chessboard can be e.g. rotated without changing
whether an assignment is a solution. Nothing is done to counter the symmetries 
in the example, in total there are only 12 unique solutions, but the example 
will give us 92 solutions in total.

These symmetries are unnecessary as they add nothing. If we are able to remove
them then we get a smaller search space, which means that we can find a 
solution faster. 

The way to remove symmetries is to inpose additional constraints that do not 
remove any unique solutions, only symmetries. We could for instance constrain
the queen in the first column to be above the queen in the last column. Any 
solution that the additional constraint invalidates can be turned into a valid 
solution through reflection in the y-axis of the board. Hence we are only 
removing symmetries, not unique solutions.

h3. Other resources

* "Modelling for Constraint Programming":http://www.math.unipd.it/~frossi/cp-school/new-barbara-tutorial.pdf 
from the "Constraint Programming summer 
school":http://www.math.unipd.it/~frossi/cp-school/.