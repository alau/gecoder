---
title: Introduction
longTitle: Documentation for Gecode/R, a Ruby Interface to Gecode
inMenu: true
description: How to use Gecode/R to model problems and solve them using constraint programming.
---
h1. Using Gecode/R

<div class="summary">
<p>To use Gecode/R to solve a problem you first have to model the problem by
expressing what a solution to the problem is using variables and 
constraints.</p>

<p>You can then fetch solutions with varying strategies.</p>
</div>

h2. Creating Models

A model is a class that mixes in {RDoc: Gecode::Mixin}.

<ruby>
class MyModel
  include Gecode::Mixin

  def initialize
    # Place variables, constraints and branching selection here.
  end
end

# Fetch the solution.
solution = MyModel.new.solve!
</ruby>

There are three main parts of a model:
<dl>
  <dt>"Variables":#variables_and_operands</dt><dd>Specify how to view the problem. A solution is an assignment of the variables.</dd>
  <dt>"Constraints":#constraints</dt><dd>Place constraints on the variables to ensure that an assignment must be a solution.</dd>
  <dt>"Branching":#branching</dt><dd>Select how the search space should be explored.</dd>
</dl>

h3. Variables and Operands

A solution to a problem is a valid assignment of the variables. The
variables can take multiple values, and it's up to Gecode to prune away
invalid assignments until a valid one is found.

Variables are the "most basic type of operand":operands/index.html. 
Operands are used as arguments to constraints and it's through them that
variables get most of their important functionality. It is common to work 
with arrays or enumerations of variables, which are also operands.

The primary variables are:
<dl>
  <dt>Integer variables</dt>
  <dd>Can be assigned integer values.
      Act as "integer operands":operands/integer-operands.html. 
      Enumerations of integer variables act as "integer enumeration
      operands":operands/integer-enum-operands.html.</dd>
  <dt>Boolean variables</dt>
  <dd>Can be assigned either true or false. Act as 
      "boolean operands":operands/boolean-operands.html. Enumerations of 
      boolean variables act as "boolean enumeration
      operands":operands/boolean-enum-operands.html.</dd>
  <dt>Set variables</dt>
  <dd>Can be assigned sets of integer values.
      Act as "set operands":operands/set-operands.html. Enumerations of 
      set variables act as "set enumeration 
      operands":operands/set-enum-operands.html.</dd>
</dl>

h4. Creating Integer Variables

Use {RDoc: Mixin#int_var} to create a new integer variable. The method takes
one argument, the domain of the integer variable. The domain represents
the values that the variable can take. A variable with domain 0..9 can
for instance take any value in the range 0 to 9. 

<ruby>
number = int_var(0..9) # Creates an integer variable with domain 0..9.
</ruby>

Alternatively one can also create multiple integer variables with the same 
domain at once using {RDoc: Mixin#int_var_array} which returns an array of variables.

<ruby>
numbers = int_var_array(8, 0..9) # Creates 8 variables with domains 0..9.
</ruby>

The domain specified does not have to be a range, it can also be an enumeration
of elements. The following creates an integer variable with the odd numbers in 
0..9 as domain.

<ruby>
odd_number = int_var([1,3,5,7,9])
</ruby>

Matrices can be created using {RDoc: Mixin#int_var_matrix} (returns an instance of
Matrix). 

<ruby>
number_matrix = int_var_matrix(5, 4, 0..9) # 5 rows and 4 columns.
</ruby>

Additional custom enumerations containing variables can be used, but they have
to be wrapped using {RDoc: Mixin#wrap_enum} first.

<ruby>
my_enum = wrap_enum(my_enum)
my_enum.must_be.distinct
</ruby>

h4. Creating Boolean Variables

Use any of {RDoc: Mixin#bool_var}, {RDoc: Mixin#bool_var_array} and 
{RDoc: Mixin#bool_var_matrix} to create boolean variables. The methods
work just like for integer variables, except for not requiring a domain.

<ruby>
bool = bool_var # Creates a boolean variable
bools = bool_var_array(3) # Creates 3 boolean variables.
bool_matrix = bool_var_matrix(3, 4) # Creates a 3x4 matrix of boolean variables.
</ruby>

h4. Creating Set Variables

Use any of {RDoc: Mixin#set_var}, {RDoc: Mixin#set_var_array} and {RDoc:
Mixin#set_var_matrix} to create set variables. The domain of a set
variable is specified through a _greatest lower bound_ (GLB), a 
_least upper bound_ (LUB) and the allowed cardinality (which is optional). 

The greatest lower bound is the largest set of elements that are certain
to be in the set, the least upper bound is the smallest set of elements
that might be in the set (which should include the greatest lower
bound). I.e. the greatest lower bound is a subset of the assigned set
which is a subset of the least upper bound.

The bounds are specified as constant sets. The cardinality can only be
specified with ranges or as a single number, which is then used as the
minimum cardinality.

A constant set can be represented with instances of the following classes:
<dl>
  <dt>Fixnum</dt><dd>Represents a singleton set.</dd>
  <dt>Range</dt><dd>Represents a set containing all elements in the range. This represents the set more efficiently than when another enumeration with the same elements are used.</dd>
  <dt>Enumeration of Fixnum</dt><dd>Represents a set containing the enumeration's elements.</dd>
</dl>

<ruby>
# Creates a set variable with glb 1..2 and lub 1..6 .
set = set_var(1..2, 1..6) 
# Creates an array of 3 set variables with the above bounds and a minimum 
# cardinality of 3.
sets = set_var_array(3, 1..2, 1..6, 3)
# Creates a 7x9 matrix of set variables with the above bounds and a cardinality 
# between 2 and 5
set_matrix = set_var_matrix(7, 9, 1..2, 1..6 2..5)
</ruby>

h4. Accessing Variables from the Outside

It is often desirable to be able to access a variable from outside the
class in order to e.g. access the selected values of the solution. One
way to do this is to assign the variable to an instance variable and
then add an accessor, but since it's such a common operation a more
convenient way has been added. Write @<variable_name>_is_a <variable>@
or @<variable_name>_is_an <variable>@, replacing @<variable_name>@ with
the variable's name and @<variable>@ with the variable, to add an
instance variable and accessor with the specified name.

To exemplify, The following two pieces of code are equivalent.
<ruby>
class Foo
  include Gecode::Mixin

  attr :digit

  def initialize
    @digit = int_var 0..9

    branch_on @digit
  end
end
</ruby>
<ruby>
class Foo
  include Gecode::Mixin

  def initialize
    digit_is_an int_var(0..9)
    
    branch_on digit
  end
end
</ruby>

h3. Constraints

Constraints specify what must hold for something to be a solution. They
are placed on operands using using @#must@ and @#must_not@ in the
following fashion:

<ruby>
operand.must.constraint_method(params)
</ruby>

For example, the following constrains @int_operand@ to be strictly
greater than 5.

<ruby>
int_operand.must > 5
</ruby>

Different operands support different constraints. See the documentation
of each operand for a complete list.

h3. Branching

The solver tries to prune the search space without actually exploring it, but
sooner or later it will probably have to make a guess about a variable's value
in order to get any further (i.e. it will have to explore the search space).
This is called branching. Which variable and selection strategies to use is 
specified with @Mixin#branch_on@

<ruby>
branch_on numbers, :variable => :smallest_size, :value => :min
</ruby>

One can specify how these guesses should be made, possibly cutting down the
search space by picking a good heuristic. An example of a common heuristic
is first fail, which makes a guess about the variable with the smallest domain 
(i.e. with lowest number of possible values). The reason why this often works
well is that we can quicker exhaust the remaining possibilities of a variable 
with a small domain, and hence force a fail (or a solution to be found) so that
we can backtrack to the next possible choice.

h2. Accessing Solutions

If you just want any or all solutions then use depth first search. Use branch 
and bound search if you want to fetch a specific solution, optimizing something
of you choice.

{RDoc: Mixin#search_stats} can be used after the search to obtain
various statistics about the search.

h3. Depth First Search

The solutions to a model can be accessed by several methods. The simplest case
is when one just want a	single solution to the problem, in which case 
{RDoc: Mixin#solve!} (which destructivly alters the instance) is 
convenient.

<ruby>
instance = MyModel.new
solution = instance.solve!
</ruby>

The model instance will reflect the found solution (i.e. all variables
accessed through the model instance will be the solution's variables) as
well as return it to be assigned to @solution@. If there is no solution
then the @Gecode::NoSolutionError@ exception is raised.

It's possible to reset the instance back to the original form using 
{RDoc: Mixin#reset!}.

<ruby>
instance.reset!
</ruby>

Note that this also resets any solutions returned earlier by 
{RDoc: Mixin#solve!}.

A similar form with blocks if also available through {RDoc: Mixin#solution}.

<ruby>
string = instance.solution{ |solution| solution.to_s }
</ruby>

It gives a solution to the block and then returns the result of the block. 
Use {RDoc: Mixin#each_solution} to iterate over all solutions to a problem.

<ruby>
instance.each_solution{ |solution| puts solution.to_s }
</ruby>

In both cases the model instance is unaffected after the method-call.

h3. Branch and Bound Search

Branch and bounds search is used when one is not just looking for _any_ 
solution, but rather the _optimal_ solution (as defined by some criteria). For 
instance we might want to find the solution which assigns the smallest value
to a price variable. This is done by using the {RDoc: Mixin#optimize!} method, which
takes a block with two arguments: the model itself and the best solution found
so far. The block should then add a constraint that constrains the model to be
strictly better than the best solution so far.

<ruby>
optimal_solution = price_model_instance.optimize! do |model, best_so_far|
  model.price.must < best_so_far.price.value
end
</ruby>

This destructively updates @price_model_instance@ to contain the returned 
solution, just like {RDoc: Mixin#solve!}. If there is not solution then 
the {RDoc: Gecode::NoSolutionError} exception is raised.

There exist convenience methods, named {RDoc: Mixin#maximize!} and {RDoc: Mixin#minimize!}, 
for optimizing single integer variables. The above minimization of the variable
@price@ can for instance also be done as follows.

<ruby>
optimal_solution = price_model_instance.minimize! :price
</ruby>

h2. Convenience

There exists handy convenience methods for common operations related to
models.

h3. Gecode.solve

Use {RDoc: Gecode.solve} to create a model and search for a single
solution without having to explicitly define a class.

<ruby>
solution = Gecode.solve do
  # Describe the model.
end
</ruby>

h3. Gecode.minimize and Gecode::maximize

Use {RDoc: Gecode.minimize} and {RDoc: Gecode.maximize} to create a
model and search for a solution that maximizes or minimizes a given
variable.

<ruby>
optimal_solution = Gecode.minimize :price do 
  # Describe the model.
end
</ruby>

h3. Gecode::Model

{RDoc: Gecode::Model} is a convenient class that only mixes in
@Gecode::Mixin@. It is useful for creating models without mixin in
Gecode::Mixin into the current context or creating a new class.

<ruby>
model = Gecode::Model.new
var = model.int_var(0..9)
var.must > 5
model.branch_on var
model.solve!

p var.value
</ruby>
