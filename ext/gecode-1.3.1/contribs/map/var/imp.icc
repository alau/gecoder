/*
 *  Main authors:
 *     Zampelli Stéphane <sz@info.ucl.ac.be> 
 *
 *  Copyright:
 *     Université catholique de Louvain, 2005
 *
 *  Last modified:
 *     $Date$
 *     $Revision$
 *
 *  This file is part of CP(Map)
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */


 #define CREATE(VY,VZ,C)                                                  \
   if (C<IntView,VY,VZ,Count::RelEqDom<IntView>,true>::post(home,newarray,y,T,c) \
       == ES_FAILED)                                                      \
     home->fail();                                                        \

namespace Gecode { namespace Map {

 forceinline MapVar::MapVar(){};//: Variable<VTI_MAP,PC_MAP_ANY>(NULL) {};

  forceinline MapVar::MapVar(Space* home, bool share, MapVar& x) : 
    //Variable<VTI_MAP,PC_MAP_ANY>(home,share,x),
    Domain(x.Domain), Codomain(x.Codomain),
    array(x.array), maxDomSize(x.maxDomSize), maxCodomSize(x.maxCodomSize),
    e(x.e), index(x.index), indexInv(x.indexInv)
  {}; 

  forceinline MapVar::MapVar(Space* home, SetVar Dom, SetVar Codom)
    : //Variable<VTI_MAP,PC_MAP_ANY>(home), 
    Domain(Dom), Codomain(Codom), 
    //This call array(...) only allocates space, does not create Views. ViewArrays are containers.
    array(home, Dom.cardMax()), 
    maxDomSize(Dom.cardMax()), maxCodomSize(Codom.cardMax()), e(NULL),
    index(NULL), indexInv(NULL)
    {
       //external pointers for private members 
       //they never change during search
       e=new std::map<int,int>;
       index=new std::map<int,int>;
       indexInv=new std::map<int,int>;

       //Create index and indexInv maps
       LubRanges<SetView> DomUB(Dom);
       Iter::Ranges::ToValues<LubRanges<SetView> > DomV(DomUB);
       int i=0;
       while (DomV()) {
	  (*index)[DomV.val()]=i;
	  (*indexInv)[i]=DomV.val();
	  ++i;
	  ++DomV;
       }

       //Fill r structure with Codomain UB 
       int *r=NULL;
       r = new int[maxCodomSize+1]; //represent the domain of Codom plus empty symbol
       LubRanges<SetView> CodomUB(Codom);
       Iter::Ranges::ToValues<LubRanges<SetView> > CodomV(CodomUB);
       i=0;
       while (CodomV()) {
	  r[i]=CodomV.val();
	  ++i;
	  ++CodomV;
       }

       //Create suitable Views and insert them into array
       for (int i=0; i<maxDomSize; i++) 
       {
	  (*e)[i]=Codom.lubMax()+i+1;  //The empty symbol is stored
	  r[maxCodomSize]=(*e)[i];
	  IntSet is(r,maxCodomSize+1);
	  IntVar myvar(home, is);
	  IntView myview(myvar);
	  array[i]=myview;
       };

	delete [] r;

       /*Post coherence constraints between array, S and T*/
       for (int i=0; i<maxDomSize; i++)
       {
	  BoolVar b1_; b1_.init(home,0,1);
	  BoolVar b1;  b1.init(home,0,1);

	  eq(home, array[i], (*e)[i], b1_);

	  bool_not(home, b1, b1_);
	  //Image_i == e <-> i \notin S
	  dom(home, Dom, SRT_SUP, (*indexInv)[i], b1);

	  //Image_i == e <-> Image_i \notin T
	  rel(home, Codom, SRT_SUP, array[i], b1);
       }

       //Post 'Occurs' constraint to propagate upon UB(T)

       //for all i in UB(Codom) : Occurs(array,i)=0 -> i \notin Codom 
       LubRanges<SetView> CodomUB2(Codom);
       Iter::Ranges::ToValues<LubRanges<SetView> > CodomV2(CodomUB2);
       while (CodomV2()) {
	  //IntVar T; T.init(home,0,maxDomSize);
	  IntVar T;T.init(home,0,maxDomSize);
	  BoolVar b1_; b1_.init(home,0,1);
	  BoolVar b2_; b2_.init(home,0,1);

	  ConstIntView y(CodomV2.val());
	  int c=0;
	  //Copy before posting, because Eq modify its own ViewArray 
	  ViewArray<IntView> newarray(home,array);  
	  //count(home, array, CodomV2.val(), IRT_EQ, T);
	  CREATE(ConstIntView,IntView,Count::Eq);

	  //b2_ <-> not(b1_) <-> T \= 0
	  eq(home, T, 0, b1_);
	  bool_not(home,b2_,b1_); 

	  //T==0 <-> y \notin Codom
	  IntVar tmp(home,CodomV2.val(), CodomV2.val());
	  IntView tmp2(tmp);
	  rel(home, Codom, SRT_SUP, tmp2, b2_ ); 

	  ++CodomV2;
       } 

    };

//  forceinline MapVar::Processor::Processor(void) {
//
//    // Combination of modification events
//    mec(ME_MAP_DOM,  ME_MAP_CODOM,  ME_MAP_ANY);
//
//    // Mapping between modification events and propagation conditions
//    mepc(ME_MAP_VAL, PC_MAP_VAL);
//    mepc(ME_MAP_DOM, PC_MAP_DOM);
//    mepc(ME_MAP_CODOM, PC_MAP_CODOM);
//    mepc(ME_MAP_ANY, PC_MAP_ANY);
//
//    // Transfer to kernel
//    enter();
//  }

  /// Return current domain cardinality minimum
  forceinline unsigned int MapVar::cardDomainMin(void) const {return Domain.cardMin();}
  /// Return current domain cardinality maximum
  forceinline unsigned int MapVar::cardDomainMax(void) const {return Domain.cardMax();}
  /// Return current codomain cardinality minimum
  forceinline unsigned int MapVar::cardCodomainMin(void) const {return Codomain.cardMin();}
  /// Return current codomain cardinality maximum
  forceinline unsigned int MapVar::cardCodomainMax(void) const {return Codomain.cardMax();}
  /// Return the \a n -th smallest element in the domain least upper bound
  forceinline int MapVar::domLubMinN(int n) const {
     SetView DomainView(Domain); //no cost thanks to compiler optimization
     return DomainView.lubMinN(n);
  }
  /// Return the \a n -th largest element in the domain least upper bound
  forceinline int MapVar::domLubMaxN(int n) const {
     SetView DomainView(Domain); //no cost thanks to compiler optimization
    return DomainView.lubMaxN(n);
  }
  /// Return the size of the domain least upper bound
  forceinline unsigned int MapVar::domLubSize(void) const {return Domain.lubSize();}
  /// Return the size of the domain greatest lower bound
  forceinline unsigned int MapVar::domGlbSize(void) const {return Domain.glbSize();}

  forceinline int MapVar::domGlbMin(void) const {return Domain.glbMin();}
  forceinline int MapVar::domGlbMax(void) const {return Domain.glbMax();}


  /// Return the \a n -th smallest element in the codomain least upper bound
  forceinline int MapVar::codomLubMinN(int n) const {
     SetView CodomainView(Codomain); //no cost thanks to compiler optimization
     return CodomainView.lubMinN(n);
  }

  /// Return the \a n -th largest element in the codomain least upper bound
  forceinline int MapVar::codomLubMaxN(int n) const {
     SetView CodomainView(Codomain); //no cost thanks to compiler optimization
     return CodomainView.lubMaxN(n);};

  forceinline int MapVar::codomGlbMin(void) const {return Codomain.glbMin();}
  forceinline int MapVar::codomGlbMax(void) const {return Codomain.glbMax();}
  forceinline int MapVar::codomLubMin(void) const {return Codomain.lubMin();}
  forceinline int MapVar::codomLubMax(void) const {return Codomain.lubMax();}

  /// Return the size of the codomain least upper bound
  forceinline unsigned int MapVar::codomLubSize(void) const {return Codomain.lubSize();}
  /// Return the size of the codomain greatest lower bound
  forceinline unsigned int MapVar::codomGlbSize(void) const {return Codomain.glbSize();}
  ///Return the initial size of UB of dom(f)
  forceinline unsigned int MapVar::maxInitDomSize(void) const {return array.size();}
  ///Returns the size of f(i)
  forceinline unsigned int MapVar::size(int i) {return array[(*index)[i]].size();}
  /// Test whether variable is assigned
  forceinline bool MapVar::assigned(void) 
  { 
    bool assigned=(Domain.assigned() && Codomain.assigned());
    if (assigned) {
      for (int i=array.size(); i--; ) {
	if ((array[i].assigned()) && (array[i].in((*e)[i]))) { assigned=false; break;  }        
      }
    }
    return assigned;
  }

  /// Test whether f(a)=b
  forceinline bool MapVar::map(int a, int b) { 
    if ( (!Domain.notContains(a)) && (!Codomain.notContains(b)) ) { 
      return ( array[(*index)[a]].assigned() && array[(*index)[a]].in(b) ); };
    return false;
  }
  ///Test wether b in f(a)
  forceinline bool MapVar::imageIn(int a, int b) { 
    if ( (!Domain.notContains(a)) && (!Codomain.notContains(b)) && (*e)[(*index)[a]]!=b) { 
      return array[(*index)[a]].in(b); };
    return false;
  }
  ///Test wether b not in f(a)
  forceinline bool MapVar::imageOut(int a, int b) { 
    if ( (!Domain.notContains(a)) && (!Codomain.notContains(b)) ) { 
      return !array[(*index)[a]].in(b) && (*e)[(*index)[a]]!=b; };
    return false;
  }
  ///Test wether \a a has no image i.e. \a a \notin Dom(f)
  forceinline bool MapVar::noImage(int a) { 
    return array[(*index)[a]].assigned() && array[(*index)[a]].in((*e)[(*index)[a]]);
  }


  /// Test whether \a f is contained in greatest lower bound
  //forceinline bool MapVar::knownIn(map<int,int> f);
  /// Test whether \a f is contained in least upper bound
  //forceinline bool MapVar::knownOut(map<int,int> f);
  //@}

  /// Include \a n in domain
  forceinline ModEvent MapVar::includeDom(Space *home, int n)
  {
    SetView DomainView(Domain); //no cost thanks to compiler optimization
    ModEvent me = DomainView.include(home, n);
    if (me == Gecode::Set::ME_SET_FAILED) {return ME_MAP_FAILED;};
    if (me == Gecode::Set::ME_SET_NONE) {return ME_MAP_NONE;};
    return ME_MAP_DOM;
  }
  /// Exclude \a n from domain
  forceinline ModEvent MapVar::excludeDom(Space *home, int n)
  {
    SetView DomainView(Domain); //no cost thanks to compiler optimization
    ModEvent me = DomainView.exclude(home, n);
    if (me == Gecode::Set::ME_SET_FAILED) {return ME_MAP_FAILED;};
    if (me == Gecode::Set::ME_SET_NONE) {return ME_MAP_NONE;};
    return ME_MAP_DOM;
  }
  /// Include \a n in codomain
  forceinline ModEvent MapVar::includeCodom(Space *home, int n)
  {
    SetView CodomainView(Codomain); //no cost thanks to compiler optimization
    ModEvent me = CodomainView.include(home, n);
    if (me == Gecode::Set::ME_SET_FAILED) {return ME_MAP_FAILED;};
    if (me == Gecode::Set::ME_SET_NONE) {return ME_MAP_NONE;};
    return ME_MAP_CODOM;
  }

  /// Exclude \a n from codomain
  forceinline ModEvent MapVar::excludeCodom(Space *home, int n)
  {
    SetView CodomainView(Codomain); //no cost thanks to compiler optimization
    ModEvent me = CodomainView.exclude(home, n);
    if (me == Gecode::Set::ME_SET_FAILED) {return ME_MAP_FAILED;};
    if (me == Gecode::Set::ME_SET_NONE) {return ME_MAP_NONE;};
    return ME_MAP_CODOM;
  }

  /// Restrict domain cardinality to be at least n 
  forceinline ModEvent MapVar::cardDomMin(Space *home, unsigned int n)
  {
    SetView DomainView(Domain); //no cost thanks to compiler optimization
    ModEvent me = DomainView.cardMin(home, n);
    if (me == Gecode::Set::ME_SET_FAILED) {return ME_MAP_FAILED;};
    if (me == Gecode::Set::ME_SET_NONE) {return ME_MAP_NONE;};
    return ME_MAP_DOM;
  }
  /// Restrict domain cardinality to be at most n
  forceinline ModEvent MapVar::cardDomMax(Space *home, unsigned int n)
  {
    SetView DomainView(Domain); //no cost thanks to compiler optimization
    ModEvent me = DomainView.cardMax(home, n);
    if (me == Gecode::Set::ME_SET_FAILED) {return ME_MAP_FAILED;};
    if (me == Gecode::Set::ME_SET_NONE) {return ME_MAP_NONE;};
    return ME_MAP_DOM;
  }
  /// Restrict codomain cardinality to be at least n
  forceinline ModEvent MapVar::cardCodomMin(Space *home, unsigned int n)
  {
    SetView CodomainView(Codomain); //no cost thanks to compiler optimization
    ModEvent me = CodomainView.cardMin(home, n);
    if (me == Gecode::Set::ME_SET_FAILED) {return ME_MAP_FAILED;};
    if (me == Gecode::Set::ME_SET_NONE) {return ME_MAP_NONE;};
    return ME_MAP_CODOM;
  }

  /// Restrict codomain cardinality to be at most n
  forceinline ModEvent MapVar::cardCodomMax(Space *home, unsigned int n) 
  {
    SetView CodomainView(Codomain); //no cost thanks to compiler optimization
    ModEvent me = CodomainView.cardMax(home, n);
    if (me == Gecode::Set::ME_SET_FAILED) {return ME_MAP_FAILED;};
    if (me == Gecode::Set::ME_SET_NONE) {return ME_MAP_NONE;};
    return ME_MAP_CODOM;
  }

  /// f(i)=j
  forceinline ModEvent MapVar::map(Space *home, int i, int j)
  {
    if ((!Domain.notContains(i)) && (!Codomain.notContains(j))) {
      ModEvent me = array[(*index)[i]].eq(home, j);
      if (me == Gecode::Int::ME_INT_FAILED) {return ME_MAP_FAILED;};
      if (me == Gecode::Int::ME_INT_NONE) {return ME_MAP_NONE;};
      return ME_MAP_ANY;
    }
    return ME_MAP_NONE;
  }

  /// f(i)\=j
  forceinline ModEvent MapVar::nomap(Space *home, int i, int j)
  {
    if ((!Domain.notContains(i)) && (!Codomain.notContains(j))) {
      ModEvent me = array[(*index)[i]].nq(home, j);
      if (me == Gecode::Int::ME_INT_FAILED) {return ME_MAP_FAILED;};
      if (me == Gecode::Int::ME_INT_NONE) {return ME_MAP_NONE;};
      return ME_MAP_ANY;
    }
    return ME_MAP_NONE;

  }

  /// f(i)\=j
  forceinline ExecStatus MapVar::nomapB(Space *home, int i, int j)
  {
    if ((!Domain.notContains(i)) && (!Codomain.notContains(j))) {
      return me_failed(array[(*index)[i]].nq(home,j)) ? ES_FAILED : ES_OK;
      //if (me == Gecode::Int::ME_INT_FAILED) {return ME_MAP_FAILED;};
      //if (me == Gecode::Int::ME_INT_NONE) {return ME_MAP_NONE;};
      //return ME_MAP_ANY;
    }
    return ES_OK;
  }


  /// Subscribe propagator \a p with propagation condition \a pc to variable
  forceinline
    GECODE_MAP_EXPORT void MapVar::subscribe(Space* home,Propagator* p,PropCond pc)
    {
      //translate pc to pc of SetView and IntViewArray
      if (pc == PC_MAP_DOM) {
	 SetView DomainView(Domain); //no cost thanks to compiler optimization
	DomainView.subscribe(home, p, Gecode::Set::PC_SET_ANY);
      }

      if (pc == PC_MAP_CODOM) {
	 SetView CodomainView(Codomain); //no cost thanks to compiler optimization
	CodomainView.subscribe(home, p, Gecode::Set::PC_SET_ANY);
      }

      if (pc == PC_MAP_ANY) {

	 SetView DomainView(Domain); //no cost thanks to compiler optimization
	 DomainView.subscribe(home, p, Gecode::Set::PC_SET_ANY);
	 SetView CodomainView(Codomain); //no cost thanks to compiler optimization
	CodomainView.subscribe(home, p, Gecode::Set::PC_SET_ANY);
	array.subscribe(home, p, Gecode::Int::PC_INT_DOM);
      }

    }

//  forceinline
//    MapVar* MapVar::copy(Space* home, bool share)
//    {
//      if (copied()) {
//	return static_cast<MapVar*>(forward()); 
//      }
//      perform_copy(home,share);
//    }

  forceinline
    void MapVar::update(Space* home, bool share, MapVar& x)
    {
      Domain.update(home, share, x.Domain);
      Codomain.update(home, share, x.Codomain);
      array.update(home, share, x.array);
      e = x.e;
      index = x.index;
      indexInv = x.indexInv;
      maxDomSize = x.maxDomSize;
      maxCodomSize = x.maxCodomSize;
   }

  /// Returns f(i) (only if f(i) is mapped)
  forceinline int MapVar::imageAssigned(int i) {return array[(*index)[i]].val();};

  ///Test wether f(i) is mapped
  forceinline bool MapVar::mapped(int i) {
    return ((array[(*index)[i]].assigned()) && (array[(*index)[i]].in((*e)[(*index)[i]])==false));};

  forceinline 
    void MapVar::print() 
    {
       for (int s=0; s<array.size(); s++)
       {
	  cout << "array[" << s << "] = " << array[s] << endl;
       }
    }

  forceinline void MapVar::print(int i)
  {
	 cout << "array[" << i << "] = " << array[i] << endl; 
  }

  forceinline MapVar::CodomLubIterator MapVar::iter_codom_lub(void) {
    LubRanges<SetView> CodomUB(Codomain);
    Iter::Ranges::ToValues<LubRanges<SetView> > CodomV(CodomUB);
    return CodomV;
  }
  


}
}

