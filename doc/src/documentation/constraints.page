---
title: Constraints
inMenu: true
description: The different constraints available in Gecode/R to use when modelling in Ruby.
---
h2. Constraints

There exist several different constraints that can be used when modelling. They
are usually used with some form of call to the methods @must@ or @must_not@ of
variables.

h3. Simple relations

Simple relation constraints can for instance specify that x must be strictly 
greater than 3, where x is an integer variable. An example of how to write that 
would be the following.

 x.must > 3

Only constant integers can be used in the right hand side at the moment. The
following relations are supported (the aliases of each relation are also 
listed).

* @<@, @lesser@, @lesser_than@
* @>@, @greater@, @greater_than@
* @>=@, @greater_or_equal@, @greater_than_or_equal_to@
* @<=@, @less_or_equal@, @less_than_or_equal_to@
* @==@, @equal@, @equal_to@

Each can be negated by using @must_not@ instead of @must@. For instance to 
express that x must not be 0 we can use the following.

 x.must_not <no_textile>==</not_textile> 0
 
The following are also other valid ways to specify that constraint.

 x.must_not.equal(0)
 x.must_not_be.equal_to(0)

h3. Linear

Linear constraints can be used to specify that a linear equation containing
variables must hold. It's specified in similar way to simple relation 
constraints. The following expresses that x + y must be equal to z + 3 where
x,y,z are all integer variables.

 (x + y).must <no_textile>==</not_textile> z + 3

The constraint supports the same relations as simple relation constraints 
inlcuding negating relations using @must_not@.

h3. Distinct

The distinct constraint is used on enumerations of integer variables an 
specifies that they must all be distinct. The following will for instance
create an array of 8 integer variables with domains 0..9 and constrain them
all to be distinct (i.e. no two integer variables in the array may take the 
same value in solution).

 numbers = int_var_array(8, 0..9)
 numbers.must_be.distinct

@must_be@ can also be replaced with @must@. The constraint does not support 
negation.

The constraint also allows offsets, so one can specify that the numbers must be
distinct after certain offsets have been applied. The following specifies that
no number may be the previous number incremented by one.

 numbers.with_offset((1..numbers.size).to_a.reverse).must_be.distinct

h3. Boolean constraints

Boolean constraints are used to place constraints on boolean variables. The 
following are some example, b1, b2 and b3 are all boolean variables.

 b1.must_be.true # Constrains b1 to be true.
 b2.must_be.false # Constraint b2 to be false.

Disjunction (or) can is expressed with @|@ and conjuntion (and) is expressed 
with @&@.

 (b1 | b2).must <no_textile>==</no_textile> b1 # Constraint the disjunction of b1 and b2 to equal b1.
 (b1 & b3).must_be.true # Constrains the conjunction of b1 and b3 to be true.

Variations of @must@ can be replaced with variations of @must_not@ to negate the
constraints. Nested expressions can be used on both sides.

 ((b1 & b1) | b3).must_not <no_textile>==</no_textile> ((b1 | b3) & b2)

h2. Options

Constraints can in general take a couple of options: *proagation strength* and
*reficiation*.

h3. Propagation strength

The propagation strength basically _suggests_ how much effort the solver puts 
into trying to prune the domains of variables using the constraint. A higher 
strength can reduce the search space quicker, but at a cost of making each 
propagation more costly (hence it's a balance).

It's usually worth testing a few different strength to see how well they work, 
a good choice of strengths can cut down the search time depending on the 
problem.

The different strengths are:
* @:value@ - value consistency (naive).
* @:domain@ - domain consistency, every element in the domain satisfies the constraint.
* @:bounds@ - bounds consistency, the boundaries of the domain satisfy the constraint.
* @:default@ - uses the default consistency for the constraint.

They are specified with the key @:strength@. The following places a domain 
consistent distinct constraint on @numbers@.

 numbers.must_be.distinct(:strength => :distinct)

h3. Reification
 
Reification is used to link a constraint to a boolean variable in such a way
that the variable is true if and only if the constraint is satisfied. The 
propagation goes both ways, so if the variable is constrained to be false then
the constraint is not allowed to be satisfied.

Reification can be thought of as a last resort glue which can be used to combine
constraints so that e.g. exactly 3 out of 17 constraints must be satisfied.

The variable to use for reification is specified with the key @:reify@. The
following connects the boolean variable @is_large@ with a relation constraint.

 number.must_be.greater_than(17, :reify => is_large)

This constraint does not force @number@ to be greater than 17 (which would be 
the case if no reification has been used).

There exist some syntactic sugar for combining reifiable constraints, which can
be used with all reifiable constraints. To express a conjunction of two 
constraints one simply places @|@ between them, analogically for conjunctions 
and @&@. The new expression is also a reifiable constraint, so one can nest the
expressions if wanted. The following constrains that either x must be less than 
0 or y must be greater than 5 and x must be 0).

 x.must < 0 | (y.must > 5 & x.must <no_textile>==</no_textile> 0)
