/*
 *  Main authors:
 *     Guido Tack <tack@gecode.org>
 *     Christian Schulte <schulte@gecode.org>
 *
 *  Contributing authors:
 *     Gabor Szokoli <szokoli@gecode.org>
 *
 *  Copyright:
 *     Guido Tack, 2004
 *     Christian Schulte, 2004
 *     Gabor Szokoli, 2004
 *
 *  Last modified:
 *     $Date: 2005-11-17 23:57:02 +0100 (Thu, 17 Nov 2005) $ by $Author: tack $
 *     $Revision: 2601 $
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

namespace Gecode { namespace Set { namespace RelOp {

  /*
   * "Ternary intersection" propagator
   *
   */

  template <class View0, class View1, class View2> ExecStatus
  Intersection<View0,View1,View2>::post(Space* home,
					View0 x0,View1 x1,View2 x2) {
    (void) new (home) Intersection<View0,View1,View2>(home,x0,x1,x2);
    return ES_OK;
  }

  template <class View0, class View1, class View2>
  Actor*
  Intersection<View0,View1,View2>::copy(Space* home, bool share) {
    return new (home) Intersection(home,share,*this);
  }


  template <class View0, class View1, class View2>
  ExecStatus
  Intersection<View0,View1,View2>::propagate(Space* home) {

    bool x0ass=x0.assigned();
    bool x1ass=x1.assigned();
    bool x2ass=x2.assigned();

    {
      GlbRanges<View2> x2lb(x2);
      GECODE_ME_CHECK( x0.includeI(home,x2lb) );
    }
    {
      GlbRanges<View2> x2lb(x2);
      GECODE_ME_CHECK( x1.includeI(home,x2lb) );
    }
    {
      GlbRanges<View0> x0lb(x0);
      LubRanges<View2> x2ub(x2);
      Iter::Ranges::Diff<GlbRanges<View0>,LubRanges<View2> > m1(x0lb,x2ub);
      GECODE_ME_CHECK( x1.excludeI(home,m1) );
    }
    {
      GlbRanges<View1> x1lb(x1);
      LubRanges<View2> x2ub(x2);

      Iter::Ranges::Diff<GlbRanges<View1>,LubRanges<View2> > m2(x1lb,x2ub);
      GECODE_ME_CHECK( x0.excludeI(home,m2) );
    }
    {
      GlbRanges<View0> x0lb(x0);
      GlbRanges<View1> x1lb(x1);
      Iter::Ranges::Inter<GlbRanges<View0>,GlbRanges<View1> > i1(x0lb,x1lb);
      GECODE_ME_CHECK( x2.includeI(home,i1) );
    }
    {
      LubRanges<View0> x0ub(x0);
      LubRanges<View1> x1ub(x1);
      Iter::Ranges::Inter<LubRanges<View0>,LubRanges<View1> > i2(x0ub,x1ub);
      GECODE_ME_CHECK( x2.intersectI(home,i2) );
    }
    unsigned int m, n;
    {
      LubRanges<View0> x0ub(x0);
      LubRanges<View1> x1ub(x1);
      Iter::Ranges::Union<LubRanges<View0>,LubRanges<View1> > u1(x0ub,x1ub);
      m = Iter::Ranges::size(u1);
      n = x0.cardMin()+x1.cardMin();
      if (n>m)
	GECODE_ME_CHECK( x2.cardMin(home,n-m) );
    }
    unsigned int s2;
    {
      LubRanges<View0> x0ub(x0);
      GlbRanges<View1> x1lb(x1);
      Iter::Ranges::Diff<GlbRanges<View1>,LubRanges<View0> > d2(x1lb,x0ub);
      s2 = Iter::Ranges::size(d2);
      assert (s2 <= x1.cardMax());
      GECODE_ME_CHECK( x2.cardMax(home,x1.cardMax()-s2) );
    }
    {
      LubRanges<View1> x1ub(x1);
      GlbRanges<View0> x0lb(x0);
      Iter::Ranges::Diff<GlbRanges<View0>,LubRanges<View1> > d1 (x0lb,x1ub);
      unsigned int s1 = Iter::Ranges::size(d1);
      assert (s1 <= x0.cardMax());
      GECODE_ME_CHECK( x2.cardMax(home,x0.cardMax()-s1) );
      if (m+x2.cardMax() > x1.cardMin())
	GECODE_ME_CHECK( x0.cardMax(home,m+x2.cardMax()-x1.cardMin()) );
      //I might have to recaluclate m here?
      if (m+x2.cardMax() > x0.cardMin())
	GECODE_ME_CHECK( x1.cardMax(home,m+x2.cardMax()-x0.cardMin()) );
      //s1 and s2 could be outdated too...
      GECODE_ME_CHECK( x0.cardMin(home,s1+x2.cardMin()) );
      GECODE_ME_CHECK( x1.cardMin(home,s2+x2.cardMin()) );
    }
    if ( x0ass + x1ass + x2ass >= 2 ) return ES_SUBSUMED;

    return ES_NOFIX;
  }

  template <class View0, class View1, class View2>
  forceinline
  Intersection<View0,View1,View2>::Intersection(Space* home,
					     View0 y0,View1 y1,View2 y2)
    : InhomTernaryPropagator<View0,PC_SET_ANY,View1,PC_SET_ANY,
			     View2,PC_SET_ANY>(home,y0,y1,y2) {}

  template <class View0, class View1, class View2>
  forceinline
  Intersection<View0,View1,View2>::Intersection(Space* home, bool share,
					     Intersection<View0,View1,View2>& p)
    : InhomTernaryPropagator<View0,PC_SET_ANY,View1,PC_SET_ANY,
			     View2,PC_SET_ANY>(home,share,p) {}

  /*
   * "Nary intersection" propagator
   *
   */

  template <class View0, class View1>
  forceinline
  IntersectionN<View0,View1>::IntersectionN(Space* home, ViewArray<View0>& x,
					    View1 y)
    : InhomNaryOnePropagator<View0,PC_SET_ANY,View1,PC_SET_ANY>(home,x,y),
      intOfDets(home) {
    shared = x.shared() || viewarrayshared(x,y);
  }

  template <class View0, class View1>
  forceinline
  IntersectionN<View0,View1>::IntersectionN(Space* home, bool share,
					    IntersectionN& p)
    : InhomNaryOnePropagator<View0,PC_SET_ANY,View1,PC_SET_ANY>(home,share,p),
      shared(p.shared),
      intOfDets() {
    intOfDets.update(home, p.intOfDets);
  }

  template <class View0, class View1>
  ExecStatus
  IntersectionN<View0,View1>::post(Space* home,
				   ViewArray<View0>& x, View1 y) {
    switch (x.size()) {
    case 0:
      GECODE_ME_CHECK(y.cardMin(home, Limits::Set::card_max));
      return ES_OK;
    case 1:
      return Rel::Eq<View0,View1>::post(home, x[0], y);
    case 2:
      return Intersection<View0,View0,View1>::post(home, x[0], x[1], y);
    default:
      (void) new (home) IntersectionN<View0,View1>(home,x,y);
      return ES_OK;
    }
  }

  template <class View0, class View1>
  Actor*
  IntersectionN<View0,View1>::copy(Space* home, bool share) {
    return new (home) IntersectionN<View0,View1>(home,share,*this);
  }

  template <class View0, class View1>
  PropCost
  IntersectionN<View0,View1>::cost(void) const {
    return PC_QUADRATIC_LO;
  }

  template <class View0, class View1>
  ExecStatus
  IntersectionN<View0,View1>::propagate(Space* home) {

    bool repeat = false;
    do {
      repeat = false;
      int xsize = x.size();

      for (int i = xsize; i--; ) {
        GECODE_ME_CHECK( y.cardMax(home,x[i].cardMax()) );
        GECODE_ME_CHECK( x[i].cardMin(home,y.cardMin()) );
        if (x[i].cardMax()==0) {
          GECODE_ME_CHECK( y.exclude(home,
                                     Limits::Set::int_min,
                                     Limits::Set::int_max) );
          intOfDets.dispose(home);
          return ES_SUBSUMED;
        }
      }
      {
        GECODE_AUTOARRAY(GlbRanges<View0>,xLBs,xsize);
        GECODE_AUTOARRAY(LubRanges<View0>,xUBs,xsize);
        for (int i = xsize; i--; ) {
          GlbRanges<View0> lb(x[i]);
          LubRanges<View0> ub(x[i]);
          xLBs[i]=lb;
          xUBs[i]=ub;
        }
        Iter::Ranges::NaryInter<GlbRanges<View0> > lbi(xLBs,xsize);
        BndSetRanges dets1(intOfDets);
        Iter::Ranges::Inter< Iter::Ranges::NaryInter<GlbRanges<View0> >,
          BndSetRanges >
          lbiAll(lbi,dets1);
        GECODE_ME_CHECK( y.includeI(home,lbiAll) );

        Iter::Ranges::NaryInter<LubRanges<View0> > ubi(xUBs,xsize);
        BndSetRanges dets2(intOfDets);
        Iter::Ranges::Inter< Iter::Ranges::NaryInter<LubRanges<View0> >,
          BndSetRanges >
          ubiAll(ubi,dets2);
        GECODE_ME_CHECK( y.intersectI(home,ubiAll) );
      }

      for (int i = xsize; i--; ) {
        GlbRanges<View1> ylb(y);
        GECODE_ME_CHECK( x[i].includeI(home,ylb) );
      }

      // xi.exclude (Intersection(xj.lb) - y.ub)
      {
        GECODE_AUTOARRAY(GLBndSet, rightSet, xsize);
        rightSet[xsize-1].init(home);
        rightSet[xsize-1].update(home,intOfDets);
        for (int i=xsize-1;i--;) {
          GlbRanges<View0> xilb(x[i+1]);
          BndSetRanges prev(rightSet[i+1]);
          Iter::Ranges::Inter<GlbRanges<View0>,
            BndSetRanges> inter(xilb,prev);
          rightSet[i].init(home);
          rightSet[i].includeI(home,inter);
        }

        LUBndSet leftAcc(home);

        for (int i=0;i<xsize;i++) {
          BndSetRanges left(leftAcc);
          BndSetRanges right(rightSet[i]);
          Iter::Ranges::Inter<BndSetRanges,
	    BndSetRanges> inter(left, right);
          LubRanges<View1> yub(y);
          Iter::Ranges::Diff<Iter::Ranges::Inter<BndSetRanges,
            BndSetRanges>, LubRanges<View1> >
	    forbidden(inter, yub);
          GECODE_ME_CHECK( x[i].excludeI(home,forbidden) );
          GlbRanges<View0> xlb(x[i]);
          leftAcc.intersectI(home,xlb);
        }
        for (int i=xsize; i--;)
          rightSet[i].dispose(home);
        leftAcc.dispose(home);
      }


      for(int i=0;i<x.size();i++){
        //Do not reverse! Eats away the end of the array!
        while (i<x.size() && x[i].assigned()) {
          GlbRanges<View0> det(x[i]);
          if (intOfDets.intersectI(home,det)) {repeat = true;}
          x.move_lst(i);
          if (intOfDets.size()==0) {
            GECODE_ME_CHECK( y.exclude(home,Limits::Set::int_min,
                                       Limits::Set::int_max) );
            intOfDets.dispose(home);
            return ES_SUBSUMED;
          }
        }
      }
      if (x.size()==0) {
	BndSetRanges all1(intOfDets);
	GECODE_ME_CHECK( y.intersectI(home,all1) );
	BndSetRanges all2(intOfDets);
	GECODE_ME_CHECK( y.includeI(home,all2) );
	intOfDets.dispose(home);
	return ES_SUBSUMED;
      }

    } while (repeat);

    return shared ? ES_NOFIX : ES_FIX;
  }

}}}

// STATISTICS: set-prop
