---
title: Set Constraints
long_title: Set constraints supported by Gecode/R
inMenu: true
description: The different set constraints available in Gecode/R for use when modelling in Ruby.
---

h2. Set constraints

In the examples @constant_set@ represents a constant set, @set@ represents a 
single set variable and @sets@ represents an enumeration of set variables.

A constant set can be represented with instances of the following classes:
* Fixnum - represents a singleton set.
* Range - represents a set containing all elements in the range. This represents the set more efficiently than when another enumeration with the same elements are used.
* Enumeration of integers - represents a set containing the enumeration's elements.

h3. Domain

Domain constraints are used to specify relations with constant sets.

<ruby>
set.must_not == constant_set
</ruby>

The following relations are supported (the aliases of each relation are also 
listed).

* @==@, @equal@, @equal_to@
* @subset@, @subset_of@
* @superset@, @superset_of@
* @disjoint@, @disjoint_with@
* @complement@, @complement_of@

h3. Relation

Relation constraints are used to specify relations with other sets.

<ruby>
set.must_be.superset_of another_set
</ruby>

The constraint supports the same relations as the domain constraint. The 
relation constraints also includes a constraint used to specify integer 
relations for each element of a set. If we for instance want the elements of a 
set to be bounded by an int var @upper_bound@ we could write the following.

<ruby>
set.elements.must <= upper_bound
</ruby>

Constant integers instead of the integer variable are also supported. Note that
this constraint is not reifiable.

h3. Cardinality

Cardinality constraints constrain the size of the set. Constraining the size of 
@set@ to be within the range @1..2@ can be expressed as follows.

<ruby>
set.size.must_be.in 1..2
</ruby>

Similarly one can constrain the cardinality to be less than an integer variable
as follows.

<ruby>
set.size.must <= number
</ruby>

Everything that's normally supported by single integer variables followed by 
@must*@ is supported after @set.size.must*@ too.

h3. Channel

This is similar to the channel constraint for integer variable enumeration, but
instead of having two integer enums we have one integer and one set enumeration.
If we revisit the integer constraint's channel example we can replace the 
position variables with several sets that are constructed so that set i contains
a position iff element i is located at that position.

<ruby>
position_sets.must.channel elements
</ruby>
or
<ruby>
elements.must.channel position_sets
</ruby>

This allows us to post constraints on @position_sets@ and have them affect
@elements@ (gaining another viewpoint). Neither negation nor reification is 
supported by the constraint.

h3. Min and max

The min and max constraints constrain the minimum and maximum of a set. The 
following constrains the minimum of @set@ to be at least 5.

<ruby>
set.min.must >= 5
</ruby>

Integer variables can also be used (instead of @5@ in the example). Everything
that's normally supported by single integer variables followed by @must*@ is 
supported after @set.min.must*@ too.