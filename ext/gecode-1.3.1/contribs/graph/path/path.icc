
/*
 *  Main authors:
 *     Grégoire Dooms <dooms@info.ucl.ac.be>
 *
 *  Copyright:
 *     Grégoire Dooms (Université catholique de Louvain), 2005
 *
 *  Last modified:
 *     $Date: 2005-11-29 10:57:21 +0100 (Tue, 29 Nov 2005) $
 *     $Revision: 271 $
 *
 *  This file is part of CP(Graph)
 *
 *  See the file "contribs/graph/LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

#include "path/pathgraphs.icc"
#include <boost/graph/iteration_macros.hpp>
#include <boost/tuple/tuple.hpp>
#include <list>
#include <map>
#include <vector>
#include <utility>

//using namespace boost;
//using namespace std;
namespace Gecode { namespace Graph {
/** Path with cost propagator */

template <class GView>
forceinline
PathCostPropag<GView>::PathCostPropag(Space* home, GView g, int st, int en, const map <pair<int,int>,int> &edgecosts, Int::IntView w)
        :  Propagator(home), g(g), start(st), end (en), ecosts(edgecosts), w(w){
                g.subscribe(home,this, Gecode::Graph::PC_GRAPH_ANY);
                w.subscribe(home,this, Gecode::Int::PC_INT_DOM);
        }

template <class GView>
        forceinline
        PathCostPropag<GView>::PathCostPropag(Space* home, bool share, PathCostPropag& p)
: Propagator(home,share,p), start(p.start), end(p.end), ecosts(p.ecosts) { 
        g.update(home,share,p.g);
        w.update(home,share,p.w);
}

template <class GView>
PathCostPropag<GView>::~PathCostPropag(void){ 
        g.cancel(this, Gecode::Graph::PC_GRAPH_ANY);
        w.cancel(this, Gecode::Int::PC_INT_DOM);
}

template <class GView>
Actor* PathCostPropag<GView>::copy(Space* home, bool share) {
        return new (home) PathCostPropag(home,share,*this);
}


template <class GView>
ExecStatus PathCostPropag<GView>::post(Space* home, GView &g,int start, int end, Int::IntView w, const map <pair<int,int>,int> &edgecosts) {
        (void) new (home) PathCostPropag(home,g, start, end, edgecosts, w);
        return ES_OK;
}

template <class GView>
PropCost PathCostPropag<GView>::cost(void) const {
        return Gecode::PC_QUADRATIC_HI;
}

template <class GView>
ExecStatus PathCostPropag<GView>::propagate(Space* home) {
        TRACE(cout << "coucou propag"<<endl);
        PathBoundsGraphs<GView> bg(g); 
        ExecStatus e= bg.SCC_filtering(home, start, end  );
        GECODE_ES_CHECK(e);
        bg.resetVertexIndexUB();
        bg.resetEdgeIndexUB();
        TRACE(cout << "cost filtering:" << endl);
        ExecStatus e2;
        int wL,wU;
        boost::tie(e2,wL,wU) = bg.cost_filtering(home, start, end, ecosts, w.max());
        //TODO define a good way (tm) of combining ExecStatus
        GECODE_ES_CHECK(e2);
        e = std::min(e,e2);
        TRACE(cout << "reducing the weight according to computed bounds:" << endl);
        GECODE_ME_CHECK(w.gq(home,wL));
        GECODE_ME_CHECK(w.lq(home,wU));
        TRACE(cout << "au revoir propag" << endl);
        return e;
}
/** Simple path propagator */

template <class GView>
forceinline
PathPropag<GView>::PathPropag(Space* home, GView g, int st, int en)
        :  Propagator(home), g(g), start(st), end (en){
                g.subscribe(home,this, Gecode::Graph::PC_GRAPH_ANY);
        }

template <class GView>
        forceinline
        PathPropag<GView>::PathPropag(Space* home, bool share, PathPropag& p)
: Propagator(home,share,p), start(p.start), end(p.end){ 
        g.update(home,share,p.g);
}

template <class GView>
PathPropag<GView>::~PathPropag(void){ 
        g.cancel(this, Gecode::Graph::PC_GRAPH_ANY);
}

template <class GView>
Actor* PathPropag<GView>::copy(Space* home, bool share) {
        return new (home) PathPropag(home,share,*this);
}


template <class GView>
ExecStatus PathPropag<GView>::post(Space* home, GView &g,int start, int end) {
        (void) new (home) PathPropag(home,g, start, end);
        return ES_OK;
}

template <class GView>
PropCost PathPropag<GView>::cost(void) const {
        return Gecode::PC_QUADRATIC_HI;
}

template <class GView>
ExecStatus PathPropag<GView>::propagate(Space* home) {
        TRACE(cout << "coucou propag"<<endl);
        PathBoundsGraphs<GView> bg(g); 
        ExecStatus e = bg.SCC_filtering(home,start,end  );
        return e;
}
} }
