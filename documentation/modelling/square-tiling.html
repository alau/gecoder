<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>Tutorial on Solving Square Tiling using Constraint Programming</title>
  <link rel="stylesheet" type="text/css" href="../../styles.css" media="screen" />
  <link rel="stylesheet" type="text/css" href="../../css/webgen.css" media="screen" />
  <meta name="description" content="How to use Gecode/R to model square tiling to solve it with constraint programming. Discusses implied constraints and symmetry breaking constraints." />
  
</head>
<body>
<div id="header">
  <a class="logoLink" href="../../index.html" title="Gecode/R - constraint programming in Ruby">
  <span>Gecode/R - constraint programming in Ruby</span>
  </a>
  <a name="top"></a>
</div>
<div id="contents">
  <div id="breadcrumbs"><a href="../../index.html">Home</a> > <a href="../index.html">Documentation</a> > <a href="index.html">Modelling</a> > <span>Modelling Square Tiling</span></div>
  <div id="sidebarWrapper">
    <div id="sidebar">
      <h3>Modelling</h3><ul id="secondNav"><li><a href="index.html">Introduction to Modelling</a></li><li><a href="sudoku.html">Modelling Sudoku</a></li><li><span>Modelling Square Tiling</span></li></ul>
      <h3>Shortcuts</h3>
      <ul class="section-links"><li><a href="#understand_the_problem">Understand the Problem</a></li><li><a href="#select_the_view">Select the View</a></li><li><a href="#express_the_constraints">Express the Constraints</a></li><li><a href="#select_branching_strategy">Select Branching Strategy</a></li><li><a href="#tweak_the_performance">Tweak the Performance</a><ul class="section-links"><li><a href="#add_implied_constraints">Add Implied Constraints</a></li><li><a href="#break_symmetries">Break Symmetries</a></li></ul></li><li><a href="#the_result">The Result</a><ul class="section-links"><li><a href="#bonus_round">Bonus Round</a></li></ul></li></ul>

      <form id="searchbox_000699377096513254569:zhhnzsrbzfu" action="http://www.google.com/cse" 
        onsubmit="pageTracker._trackPageview('/search/' + document.getElementById('q').value);">
        <fieldset>
          <legend>Search the site</legend>
          <input type="hidden" name="cx" value="000699377096513254569:zhhnzsrbzfu" />
          <input type="hidden" name="cof" value="FORID:0" />
          <input id="q" name="q" type="text" size="15" />
          <input type="submit" name="sa" value="Search" />
        </fieldset>
      </form>
    </div>
  </div>
  <div id="body">
    <h1>Modelling Square Tiling</h1>


<div class="summary">
<p>The following walks through the points of <a href="index.html">the modelling 
introduction</a> and applies them to the <a href="../../examples/square-tiling.html">square tiling problem</a>.</p>
</div>

	<h2 id="understand_the_problem">Understand the Problem</h2>


Let&#8217;s break it down.
	<ul>
	<li>The squares must cover the entire rectangle.</li>
	</ul>


	<p>Since we know that all the surface area of the squares must be used we
could stop here. There are however some notable implied conditions that
might be easier to express.</p>


	<ul>
	<li>No two squares may overlap.</li>
		<li>All squares must be placed within the rectangle.</li>
	</ul>


	<p>These two should be much easier to express, and they are enough to express the 
first point in the problem&#8217;s definition.</p>


	<h2 id="select_the_view">Select the View</h2>


	<p>It seems intuitive to view the problem as finding the positions of the squares 
in the rectangle. The squares must be placed at <em>integer positions</em>, so we lay
a grid on the rectangle and represent positions as integer coordinates.</p>


	<p>Additionally we are placing squares, so we can fully express the placement of 
a square using a single coordinate. For simplicity we choose to represent the
coordinate occupied by the upper left corner of the square.</p>


	<p>We assume that the sizes of the squares are held in a variable <code>sizes</code> and that
the dimensions of the rectangle are stored in <code>width</code> and <code>height</code>. We then
express the view as the following code.</p>


<div class="CodeRay">
  <div class="code"><pre>square_count = sizes.size
<span class="iv">@xs</span> = int_var_array(square_count, <span class="i">0</span>...width)
<span class="iv">@ys</span> = int_var_array(square_count, <span class="i">0</span>...height)
</pre></div>
</div>


	<p>The domains are derived from our coordinate system overlayed over the rectangle.</p>


	<h2 id="express_the_constraints">Express the Constraints</h2>


	<p>We need to express the following:</p>


	<ol>
	<li>No two squares may overlap.</li>
		<li>All squares must be placed within the rectangle.</li>
	</ol>


	<p>The second one is easy, we just place domain constraints on each coordinate
making sure that the coordinate can never be large enough to cause any part of
the square to leave the rectangle.</p>


<div class="CodeRay">
  <div class="code"><pre>square_count.times <span class="r">do</span> |i|
  <span class="c"># Each square must be placed within the bounds</span>
  <span class="iv">@xs</span>[i].must &lt;= width - sizes[i]
  <span class="iv">@ys</span>[i].must &lt;= height - sizes[i]
<span class="r">end</span>
</pre></div>
</div>


	<p>The first one is trickier. There does not appear to be a single constraint that
matches it, so we have to break it down into something that we can express. We
need to find a way to express that two squares do not overlap, then we can 
place that constraint on all pairs of squares.</p>


	<p>One way to say that two squares, A and B, must not overlap is that one of
the following conditions must hold.</p>


	<ul>
	<li>A is left of B</li>
		<li>A is above B</li>
		<li>B is left of A</li>
		<li>B is above A</li>
	</ul>


	<p>We can express each of those using linear constraints on the coordinates and
sizes. In other words we just need to glue them together, which is what 
reification is for. The following code expresses that, it uses the syntactic 
sugar <code>|</code> between constraints instead of defining a bunch of boolean variables.</p>


<div class="CodeRay">
  <div class="code"><pre>square_count.times <span class="r">do</span> |i|
  <span class="c"># Pairwise conditions, no pair of squares may overlap.</span>
  <span class="i">0</span>.upto(i - <span class="i">1</span>) <span class="r">do</span> |j|
    <span class="c"># That the two squares don't overlap means that i is left of j, </span>
    <span class="c"># or j is left of i, or i is above j, or j is above i.</span>
    ((<span class="iv">@xs</span>[j] - <span class="iv">@xs</span>[i]).must &gt;= sizes[i]) | 
      ((<span class="iv">@xs</span>[i] - <span class="iv">@xs</span>[j]).must &gt;= sizes[j]) | 
      ((<span class="iv">@ys</span>[j] - <span class="iv">@ys</span>[i]).must &gt;= sizes[i]) | 
      ((<span class="iv">@ys</span>[i] - <span class="iv">@ys</span>[j]).must &gt;= sizes[j])
  <span class="r">end</span>
<span class="r">end</span>
</pre></div>
</div>


	<h2 id="select_branching_strategy">Select Branching Strategy</h2>


	<p>We choose to place the squares along the x axis first, placing them from left 
to right, and then place them on the y-axis top to bottom.</p>


<div class="CodeRay">
  <div class="code"><pre>branch_on <span class="iv">@xs</span>, <span class="sy">:variable</span> =&gt; <span class="sy">:smallest_min</span>, <span class="sy">:value</span> =&gt; <span class="sy">:min</span>
branch_on <span class="iv">@ys</span>, <span class="sy">:variable</span> =&gt; <span class="sy">:smallest_min</span>, <span class="sy">:value</span> =&gt; <span class="sy">:min</span>
</pre></div>
</div>


	<h2 id="tweak_the_performance">Tweak the Performance</h2>


	<p>We can now solve small problems, but larger ones (around 50&#215;50) are problematic.
We need to tweak our model a bit.</p>


	<h3 id="add_implied_constraints">Add Implied Constraints</h3>


	<p>An implied constraint is that the sizes of the square occupying a column need
to equal the rectangle&#8217;s height. It might obvious, but it helps the solver
eliminate assignments that are never going to fit.</p>


	<p>The same is of course also true for rows and the rectangle&#8217;s width.</p>


	<p>How are we going to express it though? We need to somehow find out which 
squares occupy which columns and then sum their sizes. It sounds like we
need something conditional, so boolean variables hopefully spring to mind.</p>


	<p>The idea is to create one boolean variable per square and column combination 
and then reify it with a constraint stating that the square must be in the 
column. As a result the variable will be true exactly when the square is in the 
column.</p>


	<p>We then take advantage of linear constraints to produce the sum. We basically
weight the boolean variables with their respective sizes. A variable assigned
true becomes 1 and a variable assigned false becomes 0, so the sum will equal
the combined size of all squares that occupy the column.</p>


Expressed in code:
<div class="CodeRay">
  <div class="code"><pre><span class="c"># Columns and height.</span>
width.times <span class="r">do</span> |i|
  <span class="c"># Place the reified constraints.</span>
  occupied = bool_var_array(square_count)
  occupied.each_with_index <span class="r">do</span> |is_occupying, j|
    <span class="iv">@xs</span>[j].must_be.in((i - sizes[j] + <span class="i">1</span>)..i, <span class="sy">:reify</span> =&gt; is_occupying)
  <span class="r">end</span>

  <span class="c"># Place the constraint on the weighted sum.</span>
  occupied_sizes = occupied.zip(sizes).map{ |bool, size| bool*size }
  occupied_sizes.inject(<span class="i">0</span>){ |sum, x| x + sum }.must == height
<span class="r">end</span>

<span class="c"># Rows and width.</span>
height.times <span class="r">do</span> |i|
  <span class="c"># Place the reified constraints.</span>
  occupied = bool_var_array(square_count)
  occupied.each_with_index <span class="r">do</span> |is_occupying, j|
    <span class="iv">@ys</span>[j].must_be.in((i - sizes[j] + <span class="i">1</span>)..i, <span class="sy">:reify</span> =&gt; is_occupying)
  <span class="r">end</span>

  <span class="c"># Place the constraint on the weighted sum.</span>
  occupied_sizes = occupied.zip(sizes).map{ |bool, size| bool*size }
  occupied_sizes.inject(<span class="i">0</span>){ |sum, x| x + sum }.must == width
<span class="r">end</span>
</pre></div>
</div>


	<h3 id="break_symmetries">Break Symmetries</h3>


	<p>One symmetry is multiple squares of the same size, since we can then swap the 
two squares. To remedy this we can impose the constraint that squares of the 
same size must be sorted.</p>


<div class="CodeRay">
  <div class="code"><pre>square_count.times <span class="r">do</span> |i|
  <span class="iv">@xs</span>[i].must &lt;= <span class="iv">@xs</span>[i+<span class="i">1</span>] <span class="r">if</span> sizes[i] == sizes[i+<span class="i">1</span>]
<span class="r">end</span>
</pre></div>
</div>


	<h2 id="the_result">The Result</h2>


	<p>Combining the code from above with a small to_s method we get the following.</p>


<div class="CodeRay">
  <div class="code"><pre>require <span class="s"><span class="dl">'</span><span class="k">rubygems</span><span class="dl">'</span></span>
require <span class="s"><span class="dl">'</span><span class="k">gecoder</span><span class="dl">'</span></span>

<span class="r">class</span> <span class="cl">SquareTiling</span> 
  include <span class="co">Gecode</span>::<span class="co">Mixin</span>

  <span class="r">def</span> <span class="fu">initialize</span>(width, height, sizes)
    square_count = sizes.size

          <span class="c"># Coordinate variables.</span>
    <span class="iv">@xs</span> = int_var_array(square_count, <span class="i">0</span>...width)
    <span class="iv">@ys</span> = int_var_array(square_count, <span class="i">0</span>...height)

    <span class="c"># All squares must be placed within the rectangle.</span>
    square_count.times <span class="r">do</span> |i|
      <span class="iv">@xs</span>[i].must &lt;= width - sizes[i]
      <span class="iv">@ys</span>[i].must &lt;= height - sizes[i]
    <span class="r">end</span>

    <span class="c"># No pair of squares may overlap.</span>
    square_count.times <span class="r">do</span> |i|
      <span class="c"># Pairwise conditions, no pair of squares may overlap.</span>
      <span class="i">0</span>.upto(i - <span class="i">1</span>) <span class="r">do</span> |j|
        <span class="c"># That the two squares don't overlap means that i is left of j, </span>
        <span class="c"># or j is left of i, or i is above j, or j is above i.</span>
        ((<span class="iv">@xs</span>[j] - <span class="iv">@xs</span>[i]).must &gt;= sizes[i]) | 
          ((<span class="iv">@xs</span>[i] - <span class="iv">@xs</span>[j]).must &gt;= sizes[j]) | 
          ((<span class="iv">@ys</span>[j] - <span class="iv">@ys</span>[i]).must &gt;= sizes[i]) | 
          ((<span class="iv">@ys</span>[i] - <span class="iv">@ys</span>[j]).must &gt;= sizes[j])
      <span class="r">end</span>
    <span class="r">end</span>

    <span class="c"># Implied constraint for columns and height.</span>
    width.times <span class="r">do</span> |i|
      <span class="c"># Place the reified constraints.</span>
      occupied = bool_var_array(square_count)
      occupied.each_with_index <span class="r">do</span> |is_occupying, j|
        <span class="iv">@xs</span>[j].must_be.in((i - sizes[j] + <span class="i">1</span>)..i, <span class="sy">:reify</span> =&gt; is_occupying)
      <span class="r">end</span>

      <span class="c"># Place the constraint on the weighted sum.</span>
      occupied_sizes = occupied.zip(sizes).map{ |bool, size| bool*size }
      occupied_sizes.inject(<span class="i">0</span>){ |sum, x| x + sum }.must == height
    <span class="r">end</span>

    <span class="c"># Implied constraint for rows and width.</span>
    height.times <span class="r">do</span> |i|
      <span class="c"># Place the reified constraints.</span>
      occupied = bool_var_array(square_count)
      occupied.each_with_index <span class="r">do</span> |is_occupying, j|
        <span class="iv">@ys</span>[j].must_be.in((i - sizes[j] + <span class="i">1</span>)..i, <span class="sy">:reify</span> =&gt; is_occupying)
      <span class="r">end</span>

      <span class="c"># Place the constraint on the weighted sum.</span>
      occupied_sizes = occupied.zip(sizes).map{ |bool, size| bool*size }
      occupied_sizes.inject(<span class="i">0</span>){ |sum, x| x + sum }.must == width
    <span class="r">end</span>

    <span class="c"># Symmetry breaking constraint.</span>
    square_count.times <span class="r">do</span> |i|
      <span class="iv">@xs</span>[i].must &lt;= <span class="iv">@xs</span>[i+<span class="i">1</span>] <span class="r">if</span> sizes[i] == sizes[i+<span class="i">1</span>]
    <span class="r">end</span>

    branch_on <span class="iv">@xs</span>, <span class="sy">:variable</span> =&gt; <span class="sy">:smallest_min</span>, <span class="sy">:value</span> =&gt; <span class="sy">:min</span>
    branch_on <span class="iv">@ys</span>, <span class="sy">:variable</span> =&gt; <span class="sy">:smallest_min</span>, <span class="sy">:value</span> =&gt; <span class="sy">:min</span>
  <span class="r">end</span>

  <span class="c"># Displays the corrdinates of the squares.</span>
  <span class="r">def</span> <span class="fu">to_s</span>
    <span class="iv">@xs</span>.values.zip(<span class="iv">@ys</span>.values).map{ |x,y| <span class="s"><span class="dl">&quot;</span><span class="k">(</span><span class="il"><span class="idl">#{</span>x<span class="idl">}</span></span><span class="k">, </span><span class="il"><span class="idl">#{</span>y<span class="idl">}</span></span><span class="k">)</span><span class="dl">&quot;</span></span>}.join(<span class="s"><span class="dl">'</span><span class="k">, </span><span class="dl">'</span></span>)
  <span class="r">end</span>
<span class="r">end</span>
</pre></div>
</div>


	<p>Lets give it a try.</p>


<div class="CodeRay">
  <div class="code"><pre>puts(<span class="co">SquareTiling</span>.new(<span class="i">65</span>, <span class="i">47</span>, 
  [<span class="i">25</span>, <span class="i">24</span>, <span class="i">23</span>, <span class="i">22</span>, <span class="i">19</span>, <span class="i">17</span>, <span class="i">11</span>, <span class="i">6</span>, <span class="i">5</span>, <span class="i">3</span>]).solve! || <span class="s"><span class="dl">'</span><span class="k">Failed</span><span class="dl">'</span></span>).to_s
</pre></div>
</div>


	<p>Output:</p>


<pre>
(0, 0), (41, 23), (42, 0), (0, 25), (22, 28), (25, 0), (25, 17), (36, 17), (36, 23), (22, 25)
</pre>

	<p>The crowd goes wild!</p>


	<h3 id="bonus_round">Bonus Round</h3>


	<p>Here are some additional square tiling problems of varying sizes to test with.
Make sure to remove some of the implied and symmetry breaking constraints to 
see the difference.</p>


<div class="CodeRay">
  <div class="code"><pre><span class="co">SquareTiling</span>.new(<span class="i">1</span>, <span class="i">2</span>, [<span class="i">1</span>,<span class="i">1</span>])
<span class="co">SquareTiling</span>.new(<span class="i">5</span>, <span class="i">4</span>, [<span class="i">3</span>, <span class="i">2</span>, <span class="i">2</span>, <span class="i">1</span>, <span class="i">1</span>, <span class="i">1</span>])
<span class="co">SquareTiling</span>.new(<span class="i">4</span>, <span class="i">4</span>, [<span class="i">2</span>,<span class="i">2</span>,<span class="i">2</span>,<span class="i">2</span>])
<span class="co">SquareTiling</span>.new(<span class="i">20</span>, <span class="i">20</span>, [<span class="i">9</span>, <span class="i">8</span>, <span class="i">8</span>, <span class="i">7</span>, <span class="i">5</span>, <span class="i">4</span>, <span class="i">4</span>, <span class="i">4</span>, <span class="i">4</span>, <span class="i">4</span>, <span class="i">3</span>, <span class="i">3</span>, <span class="i">3</span>, <span class="i">2</span>, <span class="i">2</span>, <span class="i">1</span>, <span class="i">1</span>])
<span class="co">SquareTiling</span>.new(<span class="i">32</span>, <span class="i">33</span>, [<span class="i">18</span>, <span class="i">15</span>, <span class="i">14</span>, <span class="i">10</span>, <span class="i">9</span>, <span class="i">8</span>, <span class="i">7</span>, <span class="i">4</span>, <span class="i">1</span>])
<span class="co">SquareTiling</span>.new(<span class="i">65</span>, <span class="i">47</span>, [<span class="i">25</span>, <span class="i">24</span>, <span class="i">23</span>, <span class="i">22</span>, <span class="i">19</span>, <span class="i">17</span>, <span class="i">11</span>, <span class="i">6</span>, <span class="i">5</span>, <span class="i">3</span>])
<span class="co">SquareTiling</span>.new(<span class="i">112</span>, <span class="i">112</span>, [<span class="i">50</span>, <span class="i">42</span>, <span class="i">37</span>, <span class="i">35</span>, <span class="i">33</span>, <span class="i">29</span>, <span class="i">27</span>, <span class="i">25</span>, <span class="i">24</span>, <span class="i">19</span>, <span class="i">18</span>, <span class="i">17</span>, 
  <span class="i">16</span>, <span class="i">15</span>, <span class="i">11</span>, <span class="i">9</span>, <span class="i">8</span>, <span class="i">7</span>, <span class="i">6</span>, <span class="i">4</span>, <span class="i">2</span>])
<span class="co">SquareTiling</span>.new(<span class="i">175</span>, <span class="i">175</span>, [<span class="i">81</span>, <span class="i">64</span>, <span class="i">56</span>, <span class="i">55</span>, <span class="i">51</span>, <span class="i">43</span>, <span class="i">39</span>, <span class="i">38</span>, <span class="i">35</span>, <span class="i">33</span>, <span class="i">31</span>, <span class="i">30</span>, <span class="i">29</span>,
  <span class="i">20</span>, <span class="i">18</span>, <span class="i">16</span>, <span class="i">14</span>, <span class="i">9</span>, <span class="i">8</span>, <span class="i">5</span>, <span class="i">4</span>, <span class="i">3</span>, <span class="i">2</span>, <span class="i">1</span>])
</pre></div>
</div>
  </div>
  <div id="tabs"><ul><li><a href="../../features.html">Features</a></li><li><a href="../../installation.html">Installation</a></li><li><a href="../../examples/index.html">Examples</a></li><li class="selected"><a href="../index.html">Documentation</a></li><li><a href="../../details/index.html">Project Details</a></li></ul></div>
</div>
<div id="footerWrapper">
  <div id="footer"><ul><li><a href="#top">Top</a></li><li><a href="../../features.html">Features</a></li><li><a href="../../installation.html">Installation</a></li><li><a href="../../examples/index.html">Examples</a></li><li class="selected"><a href="../index.html">Documentation</a></li><li><a href="../../details/index.html">Project Details</a></li><li><a class="sitemap" href="../../sitemap.html">Sitemap</a></li></ul></div>
</div>
<script type="text/javascript">
  var gaJsHost = (("https:" == document.location.protocol) ?
  "https://ssl." : "http://www.");
  document.write(unescape("%3Cscript src='" + gaJsHost +
  "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
   var pageTracker = _gat._getTracker("UA-546645-2");
   pageTracker._initData();
   pageTracker._trackPageview();
</script>
</body>
</html>