---
title: Introduction
inMenu: true
description: How to use Gecode/R to model problems and solve them using constraint programming.
---
h2. Introduction

When using Gecode/R to solve a problem you first have to model the problem by
expressing what a solution to the problem is. Once the problem is modelled the
underlying engine will search for a solution.

A model is typically constructed by creating a class that inherits from 
@Gecode::Model@.

<ruby>
class MyModel < Gecode::Model
  def initialize
    # Place variables, constraints and branching selection here.
  end
end

# Print the solution.
puts MyModel.new.solve!.to_s
</ruby>

There are three main parts of a model:
* Variables
* Constraints
* Branching

h3. Variables

h4. Integer variables

Integer variables have domains which must be specified upon construction. The 
domain of a variable represents the values that the variable can take, for 
instance a variable might have domain 0..9 which means that it can take any 
value in the range 0 to 9. To create an integer variable we use @Model#int_var@.

<ruby>
number = int_var(0..9) # Creates an integer variable with domain 0..9.
</ruby>

Alternatively one can also create multiple integer variables with the same 
domain at once using @Model#int_var_array@ which returns an array of variables.

<ruby>
numbers = int_var_array(8, 0..9) # Creates 8 variables with domains 0..9.
</ruby>

The domain specified does not have to be a range, it can also be a series of
elements. The following creates an integer variable with the odd numbers in 
0..9 as domain.

<ruby>
odd_number = int_var(1,3,5,7,9)
</ruby>

Matrices can be created using @Model#int_var_matrix@ (returns an instance of
Matrix). 

<ruby>
number_matrix = int_var_matrix(5, 4, 0..9) # 5 rows and 4 columns.
</ruby>

Additional custom enumerations containing variables can be used, but they have
to be wrapped using @Model#wrap_enum@ first.

<ruby>
my_enum = wrap_enum(my_enum)
my_enum.must_be.distinct
</ruby>

h4. Boolean variables

Boolean variables (which can either be true or false) are created using 
@Model#bool_var@, @Model#bool_var_array@ and @Model#bool_var_matrix@, just like 
integer variables but without the need for domains.

<ruby>
bool = bool_var # Creates a boolean variable
bools = bool_var_array(3) # Creates 3 boolean variables.
bool_matrix = bool_var_matrix(3, 4) # Creates a 3x4 matrix of boolean variables.
</ruby>

h3. Constraints

The constraints specify what must hold for something to be a solution. They are
created using variables in combination with @must@ and @must_not@. The 
constraint that one variable x must be larger than another variable y is for 
instance expressed as

<ruby>
x.must > y
</ruby>

h3. Branching

The solver tries to prune the search space without actually exploring it, but
sooner or later it will probably have to make a guess about a variable's value
in order to get any further (i.e. it will have to explore the search space).
This is called branching. Which variable and selection strategies to use is 
specified with @Model#branch_on@

<ruby>
branch_on numbers, :variable => :smallest_size, :value => :min
</ruby>

One can specify how these guesses should be made, possibly cutting down the
search space by picking a good heuristic. An example of a common heuristic
is first fail, which makes a guess about the variable with the smallest domain 
(i.e. with lowest number of possible values). The reason why this often works
well is that we can quicker exhaust the remaining possibilities of a variable 
with a small domain, and hence force a fail (or a solution to be found) so that
we can backtrack to the next possible choice.