/*
 *  Main authors:
 *     Zampelli Stéphane <sz@info.ucl.ac.be>
 *
 *  Copyright:
 *     Université catholique de Louvain, 2005
 *
 *  Last modified:
 *     $Date$
 *     $Revision$
 *
 *  This file is part of CP(Map)
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */






namespace Gecode {

template <class GView>
forceinline
InducedSubgraph<GView>::InducedSubgraph(Space* home,bool share, InducedSubgraph& p) 
: Propagator(home, share,p)
{
  gp.update(home,share,p.gp);
  gt.update(home,share,p.gt);
}

template <class GView>
forceinline
InducedSubgraph<GView>::InducedSubgraph(Space* home, GView g1, GView g2) : Propagator(home), gp(g1), gt(g2) 
{
  gp.subscribe(home,this,Gecode::Graph::PC_GRAPH_ANY);
}

template <class GView>
forceinline
InducedSubgraph<GView>::~InducedSubgraph() 
{
  gp.cancel(this, Gecode::Graph::PC_GRAPH_ANY);
}

template <class GView>
forceinline
Actor *InducedSubgraph<GView>::copy(Space* home, bool share) 
{ 
  return new (home) InducedSubgraph<GView>(home,share,*this); 
}

template <class GView>
forceinline
PropCost InducedSubgraph<GView>::cost(void) const 
{
  return Gecode::PC_QUADRATIC_LO;
};

template <class GView>
forceinline
ExecStatus InducedSubgraph<GView>::post(Space* home, GView P, GView T) 
{ 
  (void) new (home) InducedSubgraph<GView>(home,P,T); return ES_OK; 
};

template <class GView>
forceinline
ExecStatus InducedSubgraph<GView>::propagate(Space* home)
{
   TRACE_MAP(cout << "inducedSubgraph" << endl);
   OutAdjSetsGraphView::GlbNodeIterator gpV = gp.iter_nodes_LB();

   while (gpV()){ 
     vector<int> V; vector<int>::iterator b; 
     gt.inNeighboursUB(gpV.val(), V); 
     for (b=V.begin(); b<V.end(); b++) {	  
       if (gp.nodeIsInLB(*b) )
       {	  
	 GECODE_ME_CHECK(gp._arcIn(home,*b,gpV.val())); 	  
       }
     }

     gt.outNeighboursUB(gpV.val(), V); 
     for (b=V.begin(); b<V.end(); b++) {	  
       if ( gp.nodeIsInLB(*b) )
       {
	 GECODE_ME_CHECK(gp._arcIn(home,gpV.val(),*b)); 	  
       }
     }

     ++gpV;
   }
   return ES_OK;
}

template <class GView>
void inducedSubgraph(Space *home, GView g1, GView g2)
{
GECODE_ES_FAIL(home,InducedSubgraph<GView>::post(home,g1,g2));
}

/*********************** CLASS Imply Arcs *****************************/

template <class GView>
forceinline
ImplyArcs<GView>::ImplyArcs(Space* home,bool share, ImplyArcs& p) 
: Propagator(home, share, p)//, gp(p.gp)), gt(p.gt)
{
TRACE_MAP(cout << "implyArcs update" << endl);
gp.update(home,share,p.gp);
gt.update(home,share,p.gt);
M.update(home,share,p.M);
}

template <class GView>
forceinline
ImplyArcs<GView>::ImplyArcs(Space* home, GView g1, GView g2, MapVar M_) : Propagator(home), gp(g1), gt(g2), M(M_) 
{
  gp.subscribe(home,this,Gecode::Graph::PC_GRAPH_ANY);
  gt.subscribe(home,this, Gecode::Graph::PC_GRAPH_ANY);
  M.subscribe(home,this,Gecode::Map::PC_MAP_ANY);
}

template <class GView>
forceinline
ImplyArcs<GView>::~ImplyArcs() 
{
  gp.cancel(this, Gecode::Graph::PC_GRAPH_ANY);
  gt.cancel(this, Gecode::Graph::PC_GRAPH_ANY);
  //M.cancel(this, Gecode::Map::PC_MAP_ANY); //VTI
}

template <class GView>
forceinline
Actor *ImplyArcs<GView>::copy(Space* home, bool share) 
{ 
  return new (home) ImplyArcs<GView>(home,share,*this); 
}

template <class GView>
forceinline
PropCost ImplyArcs<GView>::cost(void) const 
{
  return Gecode::PC_QUADRATIC_LO;
};

template <class GView>
forceinline
ExecStatus ImplyArcs<GView>::post(Space* home, GView P, GView T, MapVar M) 
{
  (void) new (home) ImplyArcs<GView>(home,P,T,M); 
  return ES_OK; 
};

template <class GView>
forceinline
ExecStatus ImplyArcs<GView>::propagate(Space* home)
{
  TRACE_MAP(cout << "BEGIN implyArcs" << endl);
  TRACE_MAP(M.print());
  //OutAdjSetsGraphView::GlbArcIterator gpV = gp.iter_arcs_LB();
  typename GView::GlbArcIterator gpV = gp.iter_arcs_LB();

  while (gpV()) {
    if ((M.mapped(gpV.val().first)) &&  (M.mapped(gpV.val().second))){
      GECODE_ME_CHECK(gt._arcIn(home, M.imageAssigned(gpV.val().first), M.imageAssigned(gpV.val().second)));
    };
    ++gpV;
  }
  TRACE_MAP(cout << "END imply arcs" << endl; M.print());
  return ES_OK;
}

template <class GView>
forceinline
void implyArcs(Space *home, GView g1, GView g2, MapVar M)
{
  GECODE_ES_FAIL(home,ImplyArcs<GView>::post(home, g1, g2, M));
}

template <class GView>
forceinline
void mono(Space *home, GView P, GView T, MapVar M)
{
  //(a,b) \in P -> (M(a),M(b)) \in T
  implyArcs(home, P, T, M);
  //M is injective
  injective(home, M);
  //|Nodes(P)|=|Nodes(T)| 
  NodeSetView<GView> nodesP(P);
  NodeSetView<GView> nodesT(T);

  //cardinality(home, nodesP, Card_P);
  IntVar Card_P; 
  Card_P.init(home, nodesP.cardMin(), nodesP.cardMax());
  if (home->failed()) return;
  GECODE_ES_FAIL(home,Gecode::Set::Int::Card::post(home, nodesP, Card_P));

  //cardinality(home, nodesT, Card_T);
  IntVar Card_T; 
  Card_T.init(home, nodesT.cardMin(), nodesT.cardMax());
  if (home->failed()) return;
  GECODE_ES_FAIL(home,Gecode::Set::Int::Card::post(home, nodesT, Card_T));

  rel(home, Card_T, IRT_EQ, Card_P);  
}

///M is a total injective monomorphic funtion from P and T 
///Propagation is performed
///Precondition : P and T must be induced. 
template <class GView>
forceinline
void monoInduced(Space *home, GView P, GView T, MapVar M)
{
  //M is injective
  injective(home, M);
  
  //|Nodes(P)|=|Nodes(T)| 
  NodeSetView<GView> nodesP(P);
  NodeSetView<GView> nodesT(T);
  
  //cardinality(home, nodesP, Card_P);
  IntVar Card_P; 
  Card_P.init(home, nodesP.cardMin(), nodesP.cardMax());
  if (home->failed()) return;
  GECODE_ES_FAIL(home,Gecode::Set::Int::Card::post(home, nodesP, Card_P));

  //cardinality(home, nodesT, Card_T);
  IntVar Card_T; 
  Card_T.init(home, nodesT.cardMin(), nodesT.cardMax());
  if (home->failed()) return;
  GECODE_ES_FAIL(home,Gecode::Set::Int::Card::post(home,nodesT, Card_T));

  rel(home, Card_T, IRT_EQ, Card_P);  
  
  GECODE_ES_FAIL(home,MonoInduced<GView>::post(home, P, T, M));
}


//M is a total injective isomorphic funtion from P to T 
template <class GView>
forceinline
void iso(Space *home, GView P, GView T, MapVar M)
{
GView Pc(home, P.lubOrder());
GView Tc(home, T.lubOrder());
complement(home, P, Pc);
complement(home, T, Tc);
mono(home, P, T, M);
mono(home, Pc,Tc,M);
};

//M is a total injective isomorphic function from P to T 
//P and T must be induced
template <class GView>
forceinline
void isoInduced(Space *home, GView P, GView T, MapVar M)
{
GView Pc(home, P.lubOrder());
GView Tc(home, T.lubOrder());
complement(home, P, Pc);
complement(home, T, Tc);
monoInduced(home, P, T, M);
monoInduced(home, Pc,Tc, M);
};

/*********************** CLASS MonoInduced *****************************/

template <class GView>
forceinline
MonoInduced<GView>::MonoInduced(Space* home,bool share, MonoInduced& p) 
: Propagator(home, share, p), last(p.last), Sin(p.Sin), Sout(p.Sout), initdone(p.initdone), left(p.left)
{
   TRACE_MAP(cout << "MonoInduced update" << endl);
   gp.update(home,share,p.gp);
   gt.update(home,share,p.gt);
   gp_ground.update(home,share,p.gp_ground);
   gt_ground.update(home,share,p.gt_ground);
   M.update(home,share,p.M);
}

template <class GView>
forceinline
pair<vector<int>,vector<pair<int,int> > > 
MonoInduced<GView>::extractUB(GView g1) 
{
   boost::tuple<vector<int>,vector<int>,vector<pair<int,int> >,vector<pair<int,int> > > graph;	 
   graph=g1.get_domain();
   pair<vector<int>,vector<pair<int,int> > > result;
   result.first=get<1>(graph);
   result.second=get<3>(graph);
   return result;
}


template <class GView>
forceinline
MonoInduced<GView>::MonoInduced(Space* home, GView g1, GView g2, MapVar M_) 
: Propagator(home, true), gp(g1), gt(g2), M(M_), gp_ground(home, extractUB(g1)), gt_ground(home, extractUB(g2)), last(gp.lubOrder()), initdone(false), left(computeLeftInit(home, gp))
{
   gp_ground.instantiateUB(home);
   gt_ground.instantiateUB(home);
   gp.subscribe(home,this,Gecode::Graph::PC_GRAPH_ANY);
   gt.subscribe(home,this, Gecode::Graph::PC_GRAPH_ANY);
   M.subscribe(home,this,Gecode::Map::PC_MAP_ANY);
   initlast(home);
   initS(home);
}

template <class GView>
forceinline
MonoInduced<GView>::~MonoInduced() 
{
//This is not called unless fd is set to true
   //gp.cancel(this, Gecode::Graph::PC_GRAPH_ANY);
   //gt.cancel(this, Gecode::Graph::PC_GRAPH_ANY);
   //M.cancel(this, Gecode::Map::PC_MAP_ANY);
}

template <class GView>
forceinline
Actor *MonoInduced<GView>::copy(Space* home, bool share) 
{ 
   return new (home) MonoInduced<GView>(home,share,*this); 
}

template <class GView>
forceinline
PropCost MonoInduced<GView>::cost(void) const 
{
  return Gecode::PC_QUADRATIC_LO;
};

template <class GView>
forceinline
ExecStatus MonoInduced<GView>::post(Space* home, GView P, GView T, MapVar M) 
{ 
   (void) new (home) MonoInduced<GView>(home,P,T,M); 
   return ES_OK; 
};

template <class GView>
forceinline
ExecStatus MonoInduced<GView>::propagate(Space* home)
{
   TRACE_MAP(cout << "MonoInduced" << endl);

   /*
      Handle initalization and precalculus
      */

   if (initdone==false) 
   {
      TRACE_MAP(cout << "beforeinit" << endl);
      TRACE_MAP(M.print());
      OutAdjSetsGraphView::LubNodeIterator gpV = gp.iter_nodes_UB();
      while (gpV()) {
	 OutAdjSetsGraphView::LubNodeIterator gtV = gt.iter_nodes_UB();
	 while (gtV()) {
	    int i=gpV.val(); int j=gtV.val();
	    //	if (gp.inDegreeLB(i) > gt.inDegreeLB(j)) {
	    //		cout << "excluding " << i << "from x" << j << endl;
	    //	  GECODE_ME_CHECK(M.nomap(home,i,j));
	    //	}
	    //	if (gp.outDegreeLB(i) > gt.outDegreeLB(j)) {
	    //		cout << "excluding " << i << "from x" << j << endl;
	    //	  GECODE_ME_CHECK(M.nomap(home,i,j));
	    //	}

	    if (getS(i,j,Sin)==0){	    
	       TRACE_MAP(cout << "Sin(" << i << "," << j << ") : " << getS(i,j,Sin) << endl);
	       TRACE_MAP(cout << "initpropag out" << endl);	
	       GECODE_ME_CHECK(_propNeighOutB(home, i, j));
	    }

	    if (getS(i,j,Sout)==0){	    
	       TRACE_MAP(cout << "Sout(" << i << "," << j << ") : " << getS(i,j,Sout) << endl);
	       TRACE_MAP(cout << "initpropag in" << endl);	
	       GECODE_ME_CHECK(_propNeighInB(home, i, j));
	    }
	    ++gtV;
	 }
	 ++gpV;
      }

   }

   TRACE_MAP(M.print());
   TRACE_MAP(cout << "afterinit" << endl);

   initdone=true;
   //TRACE_MAP(printS());
   //TRACE_MAP(printlast()); 

   /*
      Handle the optional propagation whenever a enters P
      */

   vector<int>::iterator g;
   for (g=left.begin(); g<left.end(); g++)
   {
      if (gp.nodeIsInLB(*g))
      {
	 TRACE_MAP(cout << "non selected -> selected : " << *g << endl);
	 for (int b=0; b<gt_ground.lubOrder(); b++)
	 {
	    if (getS(*g,b,Sin)==0)
	    {
	       //if (_propNeighOut(home, *g, b)==ES_FAILED) {return ES_FAILED;}
	       TRACE_MAP(cout << "prop left out" << endl);
	       //	  GECODE_ME_CHECK(_propNeighOut(home, *g, b));
	       GECODE_ME_CHECK(_propNeighOutB(home, *g, b));
	    }
	    if (getS(*g,b,Sout)==0)
	    {
	       //if (_propNeighIn(home, *g, b)==ES_FAILED) {return ES_FAILED;}
	       TRACE_MAP(cout << "prop left in " << endl); 
	       //	  GECODE_ME_CHECK(_propNeighIn(home, *g, b));
	       GECODE_ME_CHECK(_propNeighInB(home, *g, b));
	    }
	 }

	 //FIXME : slow 
	 g=left.erase(g); g--;	  
      }
   } 

   /* 
      Handle incremental calculus 
      */ 

   /* Compute Diff */

   map<int, vector<int> > diff;
   difflast(diff); //O(nd)
   TRACE_MAP(cout << "BEGIN PROPAGATION" << endl);
   TRACE_MAP(printdifflast(diff));
   TRACE_MAP(M.print());
   TRACE_MAP(cout << gp << endl);
   TRACE_MAP(cout << gt << endl);

   /*Propagate on each diff*/
   //for each x[i] that has changed
   map<int,vector<int> >::iterator i;
   for (i=diff.lower_bound(0); i!=diff.end(); ++i)
   {
      TRACE_MAP(cout << "TREATING VARIABLE X" << i->first << endl);
      vector<int>::iterator a;
      //for each lost element a of x[i]
      for (a=i->second.begin(); a<i->second.end(); a++)
      {

	 TRACE_MAP(cout << "TREATING VALUE " << *a << endl);
	 //for b in V(gt,a)
	 vector<int> V;
	 gt_ground.outNeighboursUB(*a,V);	  
	 vector<int>::iterator b;
	 for (b=V.begin(); b<V.end(); b++) {
	    TRACE_MAP(cout << "Sin[" << i->first << "," << *b << "] : " <<  getS(i->first, *b, Sin) << endl);
	    decS(i->first, *b, Sin);
	    TRACE_MAP(cout << "Sin[" << i->first << "," << *b << "] : " <<  getS(i->first, *b, Sin) << endl);
	    if (getS(i->first, *b, Sin)==0)
	    {

	       TRACE_MAP(cout << "propagateOut" << endl);
	       GECODE_ME_CHECK(_propNeighOutB(home, i->first, *b));
	    };
	 }

	 gt_ground.inNeighboursUB(*a,V);	  
	 for (b=V.begin(); b<V.end(); b++) {
	    TRACE_MAP(cout << "Sout[" << i->first << "," << *b << "] : " <<  getS(i->first, *b, Sout) << endl);
	    decS(i->first, *b, Sout);
	    TRACE_MAP(cout << "Sout[" << i->first << "," << *b << "] : " <<  getS(i->first, *b, Sout) << endl);

	    if (getS(i->first,*b,Sout)==0)
	    {
	       TRACE_MAP(cout << "propagateIn" << endl);
	       GECODE_ME_CHECK(_propNeighInB(home, i->first, *b));
	    };
	 }
      }
   }
   TRACE_MAP(M.print());
   TRACE_MAP(cout << "END PROPAGATION monoINduced" << endl);

   return ES_OK;
}

template <class GView>
forceinline
vector<int> MonoInduced<GView>::computeLeftInit(Space* home, GView g)
{
  vector<int> listOfUnknownNodes;

  OutAdjSetsGraphView::LubNodeIterator gpV = g.iter_nodes_UB();
  while (gpV()) {
     if (g.nodeIsInUB(gpV.val()) && !g.nodeIsInLB(gpV.val()))
	listOfUnknownNodes.push_back(gpV.val());
     ++gpV;
  }

  return listOfUnknownNodes;
};

template <class GView>
forceinline
ModEvent MonoInduced<GView>::_propNeighOut(Space *home, int i, int a)
{
  if (gp.nodeIsInLB(i)) { //Only if the node is selected
    vector<int> V;
    gp_ground.outNeighboursUB(i, V);  
    vector<int>::iterator j;

    for (j=V.begin(); j<V.end(); j++)
    {
      TRACE_MAP(cout << "excluding OUT " << a << " from x" << *j << endl);
      TRACE_MAP(M.print());
      return M.nomap(home, *j, a);
    }
  }
  return ME_MAP_NONE;
}

template <class GView>
forceinline
ModEvent MonoInduced<GView>::_propNeighIn(Space *home, int i, int a)
{
  if (gp.nodeIsInLB(i))  //Only if the node is selected
    {
      vector<int> V;
      gp_ground.inNeighboursUB(i, V);  
      vector<int>::iterator j;
      for (j=V.begin(); j<V.end(); j++)
	{
		TRACE_MAP(cout << "exlcuding IN " << a << " from x" << *j << endl);
		TRACE_MAP(M.print());
		return M.nomap(home, *j, a);
		TRACE_MAP(M.print());
	}
    }

  return ME_MAP_NONE;
}
template <class GView>
forceinline
ModEvent MonoInduced<GView>::_propNeighOutB(Space *home, int i, int a)
{
  if (gp.nodeIsInLB(i)) { //Only if the node is selected
    vector<int> V;
    gp_ground.outNeighboursUB(i, V);  
    vector<int>::iterator j;
    
    for (j=V.begin(); j<V.end(); j++)
      {
	ModEvent me=M.nomap(home, *j, a);
	if (::Gecode::me_failed(me))			
	   return me;
      }
  }
  return ME_MAP_NONE;
}

template <class GView>
forceinline
ModEvent MonoInduced<GView>::_propNeighInB(Space *home, int i, int a)
{
  if (gp.nodeIsInLB(i))  //Only if the node is selected
  {
    vector<int> V;
    gp_ground.inNeighboursUB(i, V);  
    TRACE_MAP(cout << "IN : gp.neighIn(" << i << ") = " << endl);
    vector<int>::iterator j;
    for (j=V.begin(); j<V.end(); j++)
    {
      TRACE_MAP(cout << "exlcuding IN " << a << " from x" << *j << endl);
      ModEvent me=M.nomap(home, *j, a);
      if (::Gecode::me_failed(me))			
	 return me;
    }
  }

  return ME_MAP_NONE;
}

template <class GView>
forceinline
void MonoInduced<GView>::printlast()
{
  cout << "LAST" << endl;
  int Msize = (int) M.maxInitDomSize();
  for (int i=0; i<Msize; i++) 
    {
      cout << "size(" << i << ") = " << last[i].first << endl;
      list<int>::iterator b;
      for (b=last[i].second.begin(); b!=last[i].second.end(); b++)
	{
	  cout << *b << " ";
	}
      cout << endl;
    }
}

template <class GView>
forceinline
void MonoInduced<GView>::printdifflast(  map<int, vector<int> >& diff)
{
  cout << "DIFFLAST : " << endl;
  for (int k1=0; k1<gp_ground.lubOrder(); k1++)
    {
      cout << "diff x[" << k1 << "] = ";
      for (int k2=0; k2<(int) diff[k1].size(); k2++)
	{
	  cout << diff[k1][k2] << " ";
	}
      cout << endl;
    }
}

template <class GView>
forceinline
void MonoInduced<GView>::printS()
{
  //for all i \in N_p
  for (int i=0; i<(int) gp_ground.lubOrder(); i++)
    {
      //for all i \in N_p
      for (int a=0; a<(int) gt_ground.lubOrder(); a++)
	{
	  cout << "Sin[" << i << "," << (int) a << "]="<<getS(i,a,Sin)<<endl;
	  cout << "Sout["<< i<<","<<(int) a << "]="<<getS(i,a,Sout)<<endl;	  
	}
      cout << endl;  
    }
}
template <class GView>
forceinline
int MonoInduced<GView>::computeSOut(int a, int b)
{
  int R=0;
  vector<int> V;
  gt_ground.outNeighboursUB(b, V);
  
  vector<int>::iterator i;
  for (i=V.begin(); i<V.end(); i++)
    {
      if (M.imageIn(a,*i)) {R++;};
    }
  return R;
}

template <class GView>
forceinline
int MonoInduced<GView>::computeSIn(int a, int b)
{
  int R=0;
  vector<int> V;
  gt_ground.inNeighboursUB(b,V);

  vector<int>::iterator i;
  for (i=V.begin(); i<V.end(); i++)
    {
      if (M.imageIn(a,*i)) {R++;};
    }
  return R;
}

template<class GView>
forceinline
void MonoInduced<GView>::initlast(Space *home)
{
  for (int i=M.maxInitDomSize(); i--; ) 
    {
      last[i].first=M.size(i);
      //Compute list of unkown
      //FIXME replace this with an iterator on M[i] instead
      list<int> R;
      MapVar::CodomLubIterator mCUB = M.iter_codom_lub();
      while (mCUB()) {
	 if (M.imageIn(i,mCUB.val()))
	    R.push_back(mCUB.val());
	 ++mCUB;
      }
      last[i].second = R;
      //domainToList(x[i], gt_ground, last[i].second);
    }

}

template <class GView>
forceinline
void MonoInduced<GView>::initS(Space *home) //O(NDd)
{

  //for all i \in N_p
  for (int i=0; i<(int) M.maxInitDomSize(); i++)
    {
      //for all i \in N_p
      for (int a=0; a<(int) gt_ground.lubOrder(); a++)
	{
	  putS(i,a,computeSIn(i, a),Sin);
	  putS(i,a,computeSOut(i, a),Sout);
	}
    }      

}

template <class GView>
forceinline
void MonoInduced<GView>::putS(int a, int b, int v, map<int,int> &S)
{
  S[(gt_ground.lubOrder()*a)+b]=v;
}

template <class GView>
forceinline
int MonoInduced<GView>::getS(int a, int b, map<int,int> &S)
{
  return S[(gt_ground.lubOrder()*a)+b];
}

template <class GView>
forceinline
void MonoInduced<GView>::decS(int a, int b, map<int,int> &S)
{
  S[(gt_ground.lubOrder()*a)+b]--;
}

template <class GView>
forceinline
void MonoInduced<GView>::difflast(map<int,vector<int> > &p)
{
  int xsize = M.maxInitDomSize(); 

  for (int i=xsize; i--; )
  {
    //if size(lb) and size(ub) has changed and it is not the empty element going out
    if (M.size(i) != (unsigned int) last[i].first) 
    {     
      list<int>::iterator a;
      for (a=last[i].second.begin(); a != last[i].second.end(); a++)
      {
	if ( (M.imageIn(i,*a)==false))
	{
	  p[i].push_back(*a);
	  //FIXME : too slow ?
	  a=last[i].second.erase(a); a--;
	}
      }
      last[i].first=M.size(i);
    }

  }//for

}

template <class GView>
void nodes(Space *home, GView g1, SetVar s)
{
	NodeSetView<GView> ng(g1);
	SetView s2(s);
	if (home->failed()) return;
	GECODE_ES_FAIL(home,(Gecode::Set::Rel::Eq<NodeSetView<GView >,SetView>::post(home,ng,s2)));
}

}
