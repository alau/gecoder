
/*
 *  Main authors:
 *     Grégoire Dooms <dooms@info.ucl.ac.be>
 *
 *  Copyright:
 *     Grégoire Dooms (Université catholique de Louvain), 2005
 *
 *  Last modified:
 *     $Date: 2005-11-29 10:57:21 +0100 (Tue, 29 Nov 2005) $
 *     $Revision: 271 $
 *
 *  This file is part of CP(Graph)
 *
 *  See the file "contribs/graph/LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

#include <boost/utility.hpp>
//using namespace boost;
namespace Gecode { namespace Graph {

/** \brief Graph Branching which selects a node or an arc to branch on, includes or excludes it.
 *
 * It is parametrized by a BoundsG : a class which must have a method 
 * pair<bool,GraphBD*> branch(Branching*); the bool must be false if no more branching is necessary 
 * otherwise it must be true and the GraphBD * points to a GraphBD.
 *
 * GraphBD should be GraphBDSimple or GraphBDMultiple.
 * It must inherit from BranchingDesc and support the data members elem and action
 * and the function members isNode and getNode.
 *
 * 
 * \ingroup TaskModelBranch
 */ 
template <class GView, class BoundsG, class GraphBD>
class UnaryGraphBranching : public Branching {
        protected:
                GView g; ///< View to branch on
                GraphBD *bd; ///< BranchingDesc telling the next first alternative
                /// Constructor for cloning \a b
                UnaryGraphBranching(Space* home, bool share, UnaryGraphBranching& b);
        public:
                /// Constructor for creation
                UnaryGraphBranching(Space* home, GView &g);
                /// Perform branching (selects view)
                virtual unsigned int branch(void);
                /// Return branching description (of type Gecode::Graph::GraphBDSingle)
                virtual BranchingDesc* description(void);
                /// Perform commit for alternative \a a and branching description \a d
                virtual ExecStatus commit(Space* home, unsigned int a, BranchingDesc* d);
                /// Perform cloning
                virtual Actor* copy(Space* home, bool share);
};

/**
 * \brief Single-type Graph %Branching descriptions 
 *
 * It stores a value of type Type  and
 * it stores wether it must be included or excluded
 *
 * This can be used to implement Arcs-only Branchings or Nodes-only Branchings
 *
 * Type should be either int or pair<int,int>
 *
 * \ingroup TaskModelBranch
 */
template <class Type>
struct GraphBDSingle : public BranchingDesc {
        typedef Type type; ///< int if a node, pair<int,int> if an arc
        const Type elem; ///< the arc or node id
        const bool action; ///< true is include and false is exclude
        /// Initialize decsription
        GraphBDSingle(Branching*,Type,bool);
        /// Report size occupied
        virtual size_t size(void) const;
        /// \brief Returns the node
        ///
        /// isNode() must return true, otherwise an assertion Error will occur 
        int getNode(void) const;
        /// tells if the value is a Node (otherwise it is an arc)
        bool isNode(void) const;
};

/**
 * \brief Multiple-type Graph %Branching descriptions 
 *
 * It might be storing either an arc or a node and 
 * it stores wether it must be included or excluded
 *
 * This should be used only to implement Arcs and Nodes Branchings 
 * \ingroup TaskModelBranch
 *
 */
struct GraphBDMultiple : public BranchingDesc {
        const pair<int,int> elem; ///< the arc or node id
        const bool type; ///< true if an arc, false if a node
        const bool action; ///< true is include and false is exclude
        /// Initialize decsription with a node
        GraphBDMultiple(Branching*,int,bool);
        /// Initialize decsription with an arc
        GraphBDMultiple(Branching*,pair<int,int>,bool);
        /// \brief Returns the node
        ///
        /// isNode() must return true, otherwise an assertion Error will occur 
        int getNode(void) const;
        /// tells if the value is a Node (otherwise it is an arc)
        bool isNode(void) const ;
        /// Report size occupied
        virtual size_t size(void) const;
};
//@}


/**
 * Graph Branching descriptions storing an arc or node and wether it must be included or excluded
 *
 * \ingroup TaskModelBranch
 */

template <class Type>
        forceinline
GraphBDSingle<Type>::GraphBDSingle(Branching* b, Type val, bool inc)
        : BranchingDesc(b), elem(val), action(inc) {
        }


template <class Type>
size_t
GraphBDSingle<Type>::size(void) const {
        return sizeof(GraphBDSingle<Type>);
}
template <>
bool
GraphBDSingle<int>::isNode(void) const {
        return true;
}
template <>
bool
GraphBDSingle<pair<int,int> >::isNode(void) const {
        return false;
}
template <>
int
GraphBDSingle<int>::getNode(void) const {
        return elem;
}
template <>
int
GraphBDSingle<pair<int,int> >::getNode(void) const {
        assert(false);
        return 0;
}

/**
 * Graph Branching descriptions storing an arc or node and wether it must be included or excluded first
 *
 * \ingroup TaskModelBranch
 */

        forceinline
GraphBDMultiple::GraphBDMultiple(Branching* b, int node, bool inc)
        : BranchingDesc(b), elem(make_pair(node,0)), type(false), action(inc) {
        }

        forceinline
GraphBDMultiple::GraphBDMultiple(Branching* b, pair<int,int> val, bool inc)
        : BranchingDesc(b), elem(val), type(true), action(inc) {
        }

size_t
GraphBDMultiple::size(void) const {
        return sizeof(GraphBDMultiple);
}

bool GraphBDMultiple::isNode() const {
        return !type;
}

int GraphBDMultiple::getNode() const{
        assert(isNode());
        return elem.first;
}


/**
 * Graph Branching which selects a node or an arc to branch on, includes or excludes it.
 *
 * \ingroup TaskModelBranch
 */

template <class GView, class BoundsG, class GraphBD>
forceinline
UnaryGraphBranching<GView,BoundsG,GraphBD>::UnaryGraphBranching
(Space* home, GView &g) : Branching(home), g(g){}


template <class GView, class BoundsG, class GraphBD>
forceinline
        UnaryGraphBranching<GView,BoundsG,GraphBD>::UnaryGraphBranching
(Space* home, bool share, UnaryGraphBranching& b)
        : Branching(home,share,b){
                g.update(home,share,b.g);
        }

template <class GView, class BoundsG, class GraphBD>
Actor*
        UnaryGraphBranching<GView,BoundsG,GraphBD>::copy(Space* home, bool share) {
                return new (home)
                        UnaryGraphBranching<GView,BoundsG,GraphBD>(home,share,*this);
        }

template <class GView, class BoundsG, class GraphBD>
unsigned int
UnaryGraphBranching<GView,BoundsG,GraphBD>::branch(void) {
        BoundsG bg(g);
        pair<bool,GraphBD*> res = bg.branch(this);
        if (! res.first) return 0;
        bd = res.second;
        return 2;
}

template <class GView, class BoundsG, class GraphBD>
BranchingDesc*
UnaryGraphBranching<GView,BoundsG,GraphBD>::description(void) {
        return bd;
}

template <class GView, class BoundsG, class GraphBD>
ExecStatus
UnaryGraphBranching<GView,BoundsG,GraphBD>::commit
(Space* home, unsigned int a, BranchingDesc* d) {
        GraphBD* lbd = static_cast<GraphBD*>(d);
        if (!lbd){
                lbd = bd;    
        }
        ModEvent me;
        if (lbd->isNode()){
                int n = lbd->getNode();
                if ((a==1)^lbd->action) {me = g._nodeIn(home,n);}
                else {me = g._nodeOut(home,n);}
        } else {
                int t,h;
                boost::tie(t,h) = lbd->elem;
                if ((a==1)^lbd->action) {me = g._arcIn(home,t,h);}
                else {me = g._arcOut(home,t,h);}
        }
        return me_failed(me) ? ES_FAILED : ES_OK;
}

template<class GView, class BoundsG>
void branch(Space * home, GView &g){
        (void) new (home) UnaryGraphBranching<GView, BoundsG, typename BoundsG::GraphBD>(home,g);
};
} }
