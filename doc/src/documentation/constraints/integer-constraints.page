---
title: Integer Constraints
long_title: Integer constraints supported by Gecode/R
inMenu: true
description: The different integer constraints available in Gecode/R for use when modelling in Ruby.
---

h2. Integer constraints

h3. Simple relations

Simple relation constraints can for instance specify that x must be strictly 
greater than 3, where x is an integer variable. An example of how to write that 
would be the following.

<ruby>
x.must > 3
</ruby>

The following relations are supported (the aliases of each relation are also 
listed).

* @<@, @lesser@, @lesser_than@
* @>@, @greater@, @greater_than@
* @>=@, @greater_or_equal@, @greater_than_or_equal_to@
* @<=@, @less_or_equal@, @less_than_or_equal_to@
* @==@, @equal@, @equal_to@

Each can be negated by using @must_not@ instead of @must@. For instance to 
express that x must not be 0 we can use the following.

<ruby>
x.must_not == 0
</ruby>
 
The following are also other valid ways to specify that constraint.

<ruby>
x.must_not.equal(0)
x.must_not_be.equal_to(0)
</ruby>

h3. Linear

Linear constraints can be used to specify that a linear equation containing
variables must hold. It's specified in similar way to simple relation 
constraints. The following expresses that x + y must be equal to z + 3 where
x,y,z are all integer variables.

<ruby>
(x + y).must == z + 3
</ruby>

The constraint supports the same relations as simple relation constraints 
inlcuding negating relations using @must_not@.

h3. Variable multiplication

Variable multiplication is also available, and works like one might expect. The
following expresses that x * y must lesser or equal to z - 9 (where x,y,z are 
all integer variables).

<ruby>
(x * y).must <= z - 9
</ruby>

h3. Domain

Domain constraints are used to change the domain of integer variables (very much
like when one specifies the domain upon construction).

<ruby>
number.must_be.in 1..4
number.must_be.in [1,3,5]
</ruby>

h3. Distinct

The distinct constraint is used on enumerations of integer variables and 
specifies that they must all be distinct. The following will for instance
create an array of 8 integer variables with domains 0..9 and constrain them
all to be distinct (i.e. no two integer variables in the array may take the 
same value in solution).

<ruby>
numbers = int_var_array(8, 0..9)
numbers.must_be.distinct
</ruby>

@must_be@ can also be replaced with @must@. The constraint does not support 
negation.

The constraint also allows offsets, so one can specify that the numbers must be
distinct after certain offsets have been applied. The following specifies that
no number may be the previous number incremented by one.

<ruby>
numbers.with_offset((1..numbers.size).to_a.reverse).must_be.distinct
</ruby>

h3. Element

The element constraint basically provides array access with variables as 
positions. Lets say that we want to purchase a fruit that costs more than 500 
units, we could model that with the following.

<ruby>
fruit_selection = int_var(0..3) # We can pick one of four fruits.
prices = wrap_enum([45, 60, 764, 45]) # The prices of each fruit.
prices[fruit_selection].must > 500
</ruby>

@fruit_selection@ will become @2@ since that's the index of the only fruit that
costs more than 500. The advantage of using arrays in this situation is that
we can represent multiple fruits with the same price, which we could not if we
for instance would constrain @price_to_pay@ directly. It doesn't matter in the 
above example, but it would matter if we for example have a situation where we 
for want to purchase as many different fruits as possible with a given budget.

In the example @prices@ is an array of constant integers, but variable integer
arrays can also be used. Everything that's normally supported for single 
integer variables followed by @must*@ is supported by the result of the array 
access too.

h3. Channel

The channel constraint is used to give access to multiple viewpoints when 
modelling. Lets say that we're modelling a sequence of numbers that must be 
distinct, we could model that as an array of integer variables where the first
variable holds the value of the first position in the sequence, the second the
value of the second position and so on.

<ruby>
elements = int_var_array(n, 0...n) # n variables with values from 0 to n-1.
elements.must_be.distinct
</ruby>

That way @elements@ will contain the actual sequence when the problem has been
solved. But we could also model it as the positions of each value in 0..(n-1) in
the sequence. That way the first variable would hold the positions of @0@ in the
sequence, the second variable would hold the positions of @1@ in the sequence 
and so on.

<ruby>
positions = int_var_array(n, 0...n)
positions.must_be.distinct
</ruby>

In essence the relationship between the arrays @elements@ and @positions@ would
be that 

<ruby>
elements.map{ |e| e.val }[i] == positions.map{ |p| p.val }.index(i)
</ruby>

for all i in 0..(n-1). They both represent different viewpoints of the sequence
and either one of them is good enough. Some constraints might however be easier
to express with one viewpoint than with the other. Hence one might want access
to both viewpoints simultaneously to use their respective advantages. This is
what the channel constraint does.

<ruby>
elements.must.channel positions
</ruby>

The above links @elements@ and @positions@ so that they always maintain the 
above property. Hence we can pick the most comfortable viewpoint for each 
constraint and use it, posting a part of the constraint from one viewpoint and 
the rest from another.

Sets can also be used instead of posistions in the above example, see the "set 
constraints":set-constraints.html for more information.

h3. Count

The count constraint is used to place constraints on the number of occurrences 
of an element in an array of integer variables. For instance we could specify 
that the number 0 may not occurr more than once in a list with the following 
(@list@ being an int var array).

<ruby>
list.count(0).must <= 1
</ruby>

Neither the element being counted nor the number of occurrences need to be 
constant, integer variables can be used instead. The following constrains the
list to contain a magic sequence, a sequence with values in 0...n that displays
on the number of i's in the sequence at position i.

<ruby>
sequence = int_var_array(n, 0...n)
n.times{ |i| sequence.count(i).must == sequence[i] }
</ruby>

The comparison itself supports everything that the simple relation constraint 
does.

h3. Min and max

The min and max constraints constrain the minimum and maximum of integer 
variable arrays. The following for instance constrains number to have a minimum
of at least 5.

<ruby>
numbers.min.must >= 5
</ruby>

Integer variables can also be used (instead of @5@ in the example). Everything
that's normally supported by single integer variables followed by @must*@ is 
supported after @min.must*@ too.

h3. Absolute value

The absolute value of a variable can be constrained using something like the
following.

<ruby>
number.abs.must >= min_abs
</ruby>

Where @number@ and @min_abs@ are integer variables. Constant integers can also
be used and everything that's normally supported for @var.must*@ is supported 
by @var.abs.must*@ too.

h3. Equality

The equality constraint used on enumerations of integer variables specifies that
all variables in the enumeration must be equal.

<ruby>
numbers.must_be.equal
</ruby>

h3. Sortedness

The sortedness constraints can be used to constraint arrays to be sorted.

<ruby>
numbers.must_be.sorted
</ruby>

The above constrains @numbers@ to be sorted. It's also possible to not affect
@numbers@ directly but rather have other arrays which represent the sorted state
of @numbers@

<ruby>
numbers.must_be.sorted(:as => sorted_numbers)
</ruby>

Where both @numbers@ and @sorted_numbers@ are integer variable enumerations. 
This can for instance be useful to force @numbers@ to be a permutation of 
@sorted_numbers@.

The order of the elements in the sorted array can also be specified (yet again 
an integer variable enum).

<ruby>
numbers.must_be.sorted(:as => sorted_numbers, :order => order)
</ruby>

The variant without @:as@ and @:order@ supports reification and negation, the 
other variations support neither.