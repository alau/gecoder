---
title: Introduction
long_title: Documentation for Gecode/R, a Ruby interface to Gecode
inMenu: true
description: How to use Gecode/R to model problems and solve them using constraint programming.
---
h2. Introduction

When using Gecode/R to solve a problem you first have to model the problem by
expressing what a solution to the problem is. Once the problem is modelled the
underlying engine will search for a solution.

A model is typically constructed by creating a class that inherits from 
@Gecode::Model@.

<ruby>
class MyModel < Gecode::Model
  def initialize
    # Place variables, constraints and branching selection here.
  end
end

# Print the solution.
puts MyModel.new.solve!.to_s
</ruby>

There are three main parts of a model:
* Variables
* Constraints
* Branching

h3. Variables

h4. Integer variables

Integer variables have domains which must be specified upon construction. The 
domain of a variable represents the values that the variable can take, for 
instance a variable might have domain 0..9 which means that it can take any 
value in the range 0 to 9. To create an integer variable we use @Model#int_var@.

<ruby>
number = int_var(0..9) # Creates an integer variable with domain 0..9.
</ruby>

Alternatively one can also create multiple integer variables with the same 
domain at once using @Model#int_var_array@ which returns an array of variables.

<ruby>
numbers = int_var_array(8, 0..9) # Creates 8 variables with domains 0..9.
</ruby>

The domain specified does not have to be a range, it can also be an enumeration
of elements. The following creates an integer variable with the odd numbers in 
0..9 as domain.

<ruby>
odd_number = int_var([1,3,5,7,9])
</ruby>

Matrices can be created using @Model#int_var_matrix@ (returns an instance of
Matrix). 

<ruby>
number_matrix = int_var_matrix(5, 4, 0..9) # 5 rows and 4 columns.
</ruby>

Additional custom enumerations containing variables can be used, but they have
to be wrapped using @Model#wrap_enum@ first.

<ruby>
my_enum = wrap_enum(my_enum)
my_enum.must_be.distinct
</ruby>

h4. Boolean variables

Boolean variables (which can either be true or false) are created using 
@Model#bool_var@, @Model#bool_var_array@ and @Model#bool_var_matrix@, just like 
integer variables but without the need for domains.

<ruby>
bool = bool_var # Creates a boolean variable
bools = bool_var_array(3) # Creates 3 boolean variables.
bool_matrix = bool_var_matrix(3, 4) # Creates a 3x4 matrix of boolean variables.
</ruby>

h4. Set variables

Set variables are created using @Model#set_var@, @Model#set_var_array@ and 
@Model#set_var_matrix@. Set variables represent sets, the domain that can be 
specified for them are the greatest lower bound (GLB), least upper bound (LUB)
and cardinality (which is optional). The bounds can be specified using either 
ranges or other enumerations. The cardinality can only be specified with ranges 
or as a single number, which is then used as the minimum cardinality.

The greatest lower bound is the largest set of elements that are certain to be 
in the set, the least upper bound is the smallest set of elements that might be
in the set (which should include the greatest lower bound). I.e. the greatest
lower bound is a subset of the assigned set which is a subset of the least upper
bound.

<ruby>
# Creates a set variable with glb 1..2 and lub 1..6 .
set = set_var(1..2, 1..6) 
# Creates an array of 3 set variables with the above bounds and a minimum cardinality of 3.
sets = set_var_array(3, 1..2, 1..6, 3)
# Creates a 7x9 matrix of set variables with the above bounds and a cardinality between 2 and 5
set_matrix = set_var_matrix(7, 9, 1..2, 1..6 2..5)
</ruby>

h3. Constraints

The constraints specify what must hold for something to be a solution. They are
created using variables in combination with @must@ and @must_not@. The 
constraint that one variable x must be larger than another variable y is for 
instance expressed as

<ruby>
x.must > y
</ruby>

h3. Branching

The solver tries to prune the search space without actually exploring it, but
sooner or later it will probably have to make a guess about a variable's value
in order to get any further (i.e. it will have to explore the search space).
This is called branching. Which variable and selection strategies to use is 
specified with @Model#branch_on@

<ruby>
branch_on numbers, :variable => :smallest_size, :value => :min
</ruby>

One can specify how these guesses should be made, possibly cutting down the
search space by picking a good heuristic. An example of a common heuristic
is first fail, which makes a guess about the variable with the smallest domain 
(i.e. with lowest number of possible values). The reason why this often works
well is that we can quicker exhaust the remaining possibilities of a variable 
with a small domain, and hence force a fail (or a solution to be found) so that
we can backtrack to the next possible choice.

h3. Accessing solutions

h4. Depth first search

The solutions to a model can be accessed by several methods. The simplest case
is when one just want a	single solution to the problem, in which case 
@Model#solve!@ (which destructivly alters the instance of @Model@) is 
convenient.

<ruby>
instance = MyModel.new
solution = instance.solve!
</ruby>

If there are no solutions then @solution@ will be @nil@ (and the instance of the
model will be untouched). If there is a solution then the model instance will
reflect that solution (i.e. all variables accessed through the model instance 
will be the solution's variables) as well as return it to be assigned to 
@solution@.

It's possible to reset the instance back to the original form using 
@Model#reset!@.

<ruby>
instance.reset!
</ruby>

Note that this also resets any solutions returned earlier by @Model#solve!@.

A similar form with blocks if also available through @Model#solution@.

<ruby>
string = instance.solution{ |solution| solution.to_s }
</ruby>

It gives a solution to the block and then returns the result of the block. 
Iterating through all solutions to a problem is done using 
@Model.each_solution@.

<ruby>
instance.each_solution{ |solution| puts solution.to_s }
</ruby>

In both cases the model instance is unaffected after the method-call.

h4. Branch and bound search

Branch and bounds search is used when one is not just looking for _any_ 
solution, but rather the _optimal_ solution (as defined by some criteria). For 
instance we might want to find the solution which assigns the smallest value
to a price variable. This is done by using the @Model#optimize!@ method, which
takes a block with two arguments: the model itself and the best solution found
so far. The block should then add a constraint that constrains the model to be
strictly better than the best solution so far.

<ruby>
optimal_solution = price_model_instance.optimize! do |model, best_so_far|
  model.price.must < best_so_far.price.val
end
</ruby>

This destructivly updates @price_model_instance@ to contain the returned 
solution, just like @Model#solve!@. If there is not solution then 
@optimal_solution@ will be assigned @nil@ and @price_model_instance@ will be
unchanged.