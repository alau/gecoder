---
title: Constraints
long_title: Constraints supported by Gecode/R
inMenu: true
description: An overview of the constraints available in Gecode/R for use when modelling in Ruby.
---
h2. Constraints

There exist several different constraints that can be used when modelling. They
are usually used with some form of call to the methods @must@ or @must_not@ of
variables. The following for instance constrains an integer variable x to be
strictly larger than 5.

<ruby>
x.must > 5
</ruby>

Using @must@ instead of @must_not@ negates the constraints. Not all constraints
support that however. The constraints that are currently supported are divided
into the following categories.

* "Integer constraints":integer-constraints.html - Constraints dealing with finite domain integer variables.
* "Boolean constraints":boolean-constraints.html - Constraints dealing with boolean variables.
* "Set constraints":set-constraints.html - Constraints dealing with finite integer set variables.

The RDoc documentation contains additional examples of all types of constraints.
The "quick reference":quick-reference.html provides a list containing all of 
them.

h2. Options

Constraints can in general take a couple of options: *proagation strength* and
*reficiation*.

h3. Propagation strength

The propagation strength basically _suggests_ how much effort the solver puts 
into trying to prune the domains of variables using the constraint. A higher 
strength can reduce the search space quicker, but at the cost of making each 
propagation more costly.

Note that no set constraint accepts the propagation strength option.

It's usually worth testing a few different strength to see how well they work, 
a good choice of strengths can cut down the search time depending on the 
problem.

The different strengths are:
* @:value@ - value consistency (naive).
* @:bounds@ - bounds consistency.
* @:domain@ - domain consistency.
* @:default@ - uses the default consistency of the constraint.

They are specified with the key @:strength@. The following places a domain 
consistent distinct constraint on @numbers@.

<ruby>
numbers.must_be.distinct(:strength => :domain)
</ruby>

The strength generally progresses as @:value@ -> @:bounds@ -> @:domain@ 
(@:value@ being the weakest, @:domain@ being the strongest). 

h3. Reification
 
Reification is used to link a constraint to a boolean variable in such a way
that the variable is true if and only if the constraint is satisfied. The 
propagation goes both ways, so if the variable is constrained to be false then
the constraint is not allowed to be satisfied.

Reification can be thought of as a last resort glue which can be used to combine
constraints so that e.g. exactly 3 out of 17 constraints must be satisfied.

The variable to use for reification is specified with the key @:reify@. The
following connects the boolean variable @is_large@ with a relation constraint.

<ruby>
number.must_be.greater_than(17, :reify => is_large)
</ruby>

This constraint does not force @number@ to be greater than 17 (which would be 
the case if no reification has been used).

There exist some syntactic sugar for combining reifiable constraints, which can
be used with all reifiable constraints. To express a conjunction of two 
constraints simply place @|@ between them, analogically for conjunctions and 
@&@. The new expression is also a reifiable constraint, so one can nest the
expressions if wanted. The following constrains that either x must be less than 
0 or y must be greater than 5 and x must be 0.

<ruby>
x.must < 0 | (y.must > 5 & x.must == 0)
</ruby>