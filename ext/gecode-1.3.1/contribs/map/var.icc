/*
 *  Main authors:
 *     Zampelli Stéphane <sz@info.ucl.ac.be> 
 *
 *  Copyright:
 *     Université catholique de Louvain, 2005
 *
 *  Last modified:
 *     $Date$
 *     $Revision$
 *
 *  This file is part of CP(Map)
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

#include "int/count.hh" //for the count constraint
#include <iostream>
#include <map>
#include <vector>

/**
 * \namespace Gecode::Map
 * \brief Contains the MapVar declarations with propagator classes
 *
 */
//@{

//#include "constraints.hh" //Declaration of FRIEND propagator functions in Gecode namespace 


namespace Gecode { namespace Map {

  /**
   * \defgroup TaskActorMapMEPC Map modification events and propagation conditions
   * \ingroup TaskActorMap
   */

  //@{

  /// Domain operation has resulted in failure
  const ModEvent ME_MAP_FAILED = ME_GEN_FAILED;
  /// Domain operation has not changed domain
  const ModEvent ME_MAP_NONE  = ME_GEN_NONE;
  /// Domain operation has resulted in a value (assigned variable)
  const ModEvent ME_MAP_VAL   = ME_GEN_ASSIGNED;


  /*ModEvents declaration*/
  
  /**
   * \brief Domain operation has changed the domain 
   *
   * Note that this implies that the domain has not resulted in a value.
   */
  const ModEvent ME_MAP_DOM   = ME_MAP_VAL + 1;
  /**
   * \brief Domain operation has changed the codomain 
   *
   * Note that this implies that the domain has not resulted in a value.
   */
  const ModEvent ME_MAP_CODOM   = ME_MAP_DOM + 1;
  /**
   * \brief Domain operation has changed both greatest domain and 
   * codomain
   *
   * Note that this implies that the domain has not resulted in a value.
   */
  const ModEvent ME_MAP_ANY   = ME_MAP_CODOM + 1;

  /*Propagation conditions declaration*/
  
  /**
   * \brief Propagate when a view becomes assigned (single value)
   *
   * If a propagator \a p depends on a view \a x with propagation
   * condition PC_MAP_VAL, then \a p is propagated when a domain
   * update operation on \a x returns the modification event ME_MAP_VAL.
   */
  const PropCond PC_MAP_VAL  = PC_GEN_ASSIGNED;
  /**
   * \brief Propagate when the codomain changes
   *
   * If a propagator \a p depends on a view \a x with propagation
   * condition PC_MAP_DOM, then \a p is propagated when a domain
   * update operation on \a x returns the modification event ME_MAP_VAL,
   * ME_MAP_DOM, ME_MAP_ANY
   */
  const PropCond PC_MAP_DOM = PC_MAP_VAL + 1;
  /**
   * \brief Propagate when the codom changes
   *
   * If a propagator \a p depends on a view \a x with propagation
   * condition PC_MAP_CODOM, then \a p is propagated when a domain
   * update operation on \a x returns the modification event ME_MAP_VAL,
   * ME_MAP_CODOM, ME_MAP_ANY
   */
  const PropCond PC_MAP_CODOM = PC_MAP_DOM + 1;
  /**
   * \brief Propagate when the domain or/and the codomain changes
   *
   * If a propagator \a p depends on a view \a x with propagation
   * condition PC_MAP_ANY, then \a p is propagated when a domain
   * update operation on \a x returns any modification event but ME_MAP_FAILED
   * and ME_MAP_NONE.
   */
  const PropCond PC_MAP_ANY  = PC_MAP_CODOM + 1;
  //@}
}}

namespace Gecode { namespace Map {
class MapVar;
}}

namespace Gecode {void injective(Space *home, Gecode::Map::MapVar M);}

namespace Gecode { namespace Map {

   /**
    * \defgroup FIMV Finite Integer Map Variable 
    *
    * This implementation uses an Array of IntView to represent the matching, together 
    * with one SetView for the domain and one SetView for the codomain. 
    *
    * Reified propagators are posted to ensure coherence between the array and the Set variables. 
    * 
    */  
   //@{
    /**
    * \brief Implementation of Finite Integer Map Variable 
    *
    * This implementation uses an Array of IntView to represent the matching, together 
    * with one SetView for the domain and one SetView for the codomain. 
    *
    * Reified propagators are posted to ensure coherence between the array and the Set variables. 
    *
    */  
  
   class MapVar 
	   //: public Variable<VTI_MAP,PC_MAP_ANY> 
	   {
	 public:
	 ///Repesents the domain
	 Gecode::SetVar Domain;
	 ///Represents the codomain
	 Gecode::SetVar Codomain;
	 ///Represents the map
	 ViewArray<Gecode::Int::IntView> array;  
	 ///Size of the initial domain
	 int maxDomSize;     
	 ///Size of the initial codomain
	 int maxCodomSize;     
	 ///Stores the empty symbol for each IntVar (alldiff)
	 map < int, int > *e;     
	 ///Maps real domain values to technical \f$\{0,\ldots,n-1\}\f$ indexes
	 map < int,int > *index;
	 ///Maps indexes to real domain values
	 map < int,int > *indexInv; 


//	 /// Map variable processor for modified variables
//	 class Processor : public VarTypeProcessor<VTI_MAP,PC_MAP_ANY> {
//	    public:
//	       /// Initialize and register
//	       Processor(void);
//	 };
//	 /// The processor
//	 GECODE_MAP_EXPORT static Processor svp;

      protected:
	 /// Constructor for cloning \a x
	 MapVar(Space* home, bool share, MapVar& x);
	 /// Destructor 
	 //~MapVar();
      public:

	 /// \name Constructors and initialization
	 //@{
	 MapVar(void);

	 // Initialize with empty lower and full upper bound
	 //    MapVar(Space* home);
	 /// Initialize with a SetView Dom representing the domain and a SetView Codom representing the codomain. 
	 MapVar(Space* home, SetVar Dom, SetVar Codom);
	 //@}

	 /// \name Value access
	 //@{
	 /// Return current domain cardinality minimum
	 unsigned int cardDomainMin(void) const;
	 /// Return current domain cardinality maximum
	 unsigned int cardDomainMax(void) const;
	 /// Return current codomain cardinality minimum
	 unsigned int cardCodomainMin(void) const;
	 /// Return current codomain cardinality maximum
	 unsigned int cardCodomainMax(void) const;
	 /// Return the \a n -th smallest element in the domain least upper bound
	 int domLubMinN(int n) const;
	 /// Return the \a n -th largest element in the domain least upper bound
	 int domLubMaxN(int n) const;
	 /// Return the smallest element in the domain greatest lower bound
	 int domGlbMin() const;
	 /// Return the largest element in the domain least upper bound
	 int domGlbMax() const;
	 /// Return the size of the domain least upper bound
	 unsigned int domLubSize(void) const;
	 /// Return the size of the domain greatest lower bound
	 unsigned int domGlbSize(void) const;
	 /// Return the \a n -th smallest element in the codomain least upper bound
	 int codomLubMinN(int n) const;
	 /// Return the \a n -th largest element in the codomain least upper bound
	 int codomLubMaxN(int n) const;
	 /// Return the smallest element in the codomain greatest lower bound
	 int codomGlbMin() const;
	 /// Return the largest element in the codomain greatest lower bound
	 int codomGlbMax() const;
	 /// Return the smallest element in the codomain least upper bound
	 int codomLubMin() const;
	 /// Return the largest element in the codomain least upper bound
	 int codomLubMax() const;
	 /// Return the size of the codomain least upper bound
	 unsigned int codomLubSize(void) const;
	 /// Return the size of the codomain greatest lower bound
	 unsigned int codomGlbSize(void) const;
	 /// Return the number of potential images of \f$f(i)\f$
	 unsigned int size(int i);
	 /// Return \f$f(i)\f$ (only if f(i) is mapped)
	 int MapVar::imageAssigned(int i);
	 /// Return the size of the initial upper bound of dom(f)
	 unsigned int maxInitDomSize(void) const;
	 //@}

	 /// \name Domain tests
	 //@{
	 ///Test wether f(i) is mapped
	 bool mapped(int i) ;
	 /// Test whether variable is assigned
	 bool assigned(void) ;
	 /// Test whether \f$f(a)=b\f$
	 bool map(int a, int b);
	 ///Test wether \f$ b \in f(a)\g$
	 bool imageIn(int a, int b);
	 ///Test wether \f$b \notin f(a)\f$
	 bool imageOut(int a, int b);
	 ///Test wether \a a has no image i.e. \f$ a \notin Dom(f)\f$
	 bool noImage(int a);
	 //
	 ///Test wether \a f is in least upper bound
	 //bool knownOut(map<int,int> f);
	 ///Test wether\a f is in grestest lower bound
	 //bool knownIn(map<int,int> f);
	 //@}


      private:
	 /// Test whether glb is a subset of lub
	 //bool boundsConsistent(void) const;
      public:

	 /// \name Domain update by value
	 //@{

	 /// Include \a n in domain
	 ModEvent includeDom(Space *home, int n);
	 /// Exclude \a n from domain
	 ModEvent excludeDom(Space *home, int n);
	 /// Include \a n in codomain
	 ModEvent includeCodom(Space *home, int n);
	 /// Exclude \a n from codomain
	 ModEvent excludeCodom(Space *home, int n);

	 /// Restrict domain cardinality to be at least n 
	 ModEvent cardDomMin(Space *home, unsigned int n);
	 /// Restrict domain cardinality to be at most n
	 ModEvent cardDomMax(Space *home, unsigned int n);
	 /// Restrict codomain cardinality to be at least n
	 ModEvent cardCodomMin(Space *home, unsigned int n);
	 /// Restrict codomain cardinality to be at most n
	 ModEvent cardCodomMax(Space *home, unsigned int n); 

	 /// f(i)=j
	 ModEvent map(Space *home, int i, int j);
	 /// f(i)\=j
	 ModEvent nomap(Space *home, int i, int j);
	 ExecStatus nomapB(Space *home, int i, int j);
	 //@}

	 /// \name Domain update by range iterator
	 //@{
	 /// Include set described by \a i in the greatest lower bound
	 //template <class I> ModEvent includeI(Space* home,I& i);
	 /// Exclude set described by \a i from the least upper bound
	 //template <class I> ModEvent excludeI(Space* home,I& i);
	 /// Exclude everything but set described by \a i from the least upper bound
	 //template <class I> ModEvent intersectI(Space* home,I& i);
	 //@}

	 typedef Iter::Ranges::ToValues<LubRanges<SetView> > CodomLubIterator ;
	 CodomLubIterator iter_codom_lub();

      public:
	 /// \name Dependencies
	 //@{
	 /// Subscribe propagator \a p with propagation condition \a pc to variable
	 GECODE_MAP_EXPORT void subscribe(Space* home,Propagator* p,PropCond pc);
	 //@}

      private:
	 /// Return copy of not-yet copied variable
	 GECODE_MAP_EXPORT MapVar* perform_copy(Space* home, bool share);

      public:
	 /// \name Cloning
	 //@{
	 /// Return copy of this variable
	 MapVar* copy(Space* home, bool share);
	 /// Update this variable to be a clone of variable \a x
	 void update(Space* home, bool share, MapVar& x);
	 //@}

	 void print(void);
	 void print(int i); 

	 //friend void Gecode::branch(Space *home, MapVar M, BvarSel vars, BvalSel vals);
	 //friend void Gecode::injective(Gecode::Space *, MapVar);
   };
   //a}
}
}

#include "var/imp.icc"
//@}

/**
 * \brief Print set variable \a x
 * \relates Gecode::MapVar
 */
GECODE_MAP_EXPORT std::ostream&
operator<<(std::ostream&, const Gecode::Map::MapVar& x);

//
// STATISTICS: set-var
//
