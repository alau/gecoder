var search_data = {"index":{"info":[["Gecode","","Gecode.html","","<p>Problems can be formulated and solved either through defining a new class\nthat mixes in Gecode::Mixin …\n"],["Gecode::Bool","","Gecode/Bool.html","",""],["Gecode::Bool::BoolConstraintReceiver","","Gecode/Bool/BoolConstraintReceiver.html","","<p>BoolConstraintReceiver contains all constraints that can be placed on a\nBoolOperand.\n<p>Constraints are placed …\n"],["Gecode::Bool::BoolOperand","","Gecode/Bool/BoolOperand.html","","<p>A BoolOperand is a combination of variables on which the constraints\ndefined in BoolConstraintReceiver …\n"],["Gecode::BoolEnum","","Gecode/BoolEnum.html","",""],["Gecode::BoolEnum::BoolEnumConstraintReceiver","","Gecode/BoolEnum/BoolEnumConstraintReceiver.html","","<p>BoolEnumConstraintReceiver contains all constraints that can be placed on a\nBoolEnumOperand.\n<p>Constraints …\n"],["Gecode::BoolEnum::BoolEnumOperand","","Gecode/BoolEnum/BoolEnumOperand.html","","<p>A BoolEnumOperand is a enumeration of BoolOperand on which the constraints\ndefined in BoolEnumConstraintReceiver …\n"],["Gecode::BoolVar","","Gecode/BoolVar.html","","<p>Describes a boolean variable.\n<p>A boolean variable can be either true or false.\n<p>Boolean variables are boolean …\n"],["Gecode::ConstraintReceiver","","Gecode/ConstraintReceiver.html","","<p>Describes a constraint receiver, something that receives and  places\nconstraints on various Operand. …\n"],["Gecode::FixnumEnum","","Gecode/FixnumEnum.html","",""],["Gecode::FixnumEnum::FixnumEnumOperand","","Gecode/FixnumEnum/FixnumEnumOperand.html","","<p>A FixnumEnumOperand is a enumeration of Fixnum on which the constraints\ndefined in FixnumEnumConstraintReceiver …\n"],["Gecode::Int","","Gecode/Int.html","",""],["Gecode::Int::IntConstraintReceiver","","Gecode/Int/IntConstraintReceiver.html","","<p>IntConstraintReceiver contains all constraints that can be placed on an\nIntOperand.\n<p>Constraints are placed …\n"],["Gecode::Int::IntOperand","","Gecode/Int/IntOperand.html","","<p>A IntOperand is a combination of variables on which the constraints defined\nin IntConstraintReceiver …\n"],["Gecode::IntEnum","","Gecode/IntEnum.html","",""],["Gecode::IntEnum::IntEnumConstraintReceiver","","Gecode/IntEnum/IntEnumConstraintReceiver.html","","<p>IntEnumConstraintReceiver contains all constraints that can be placed on a\nIntEnumOperand.\n<p>Constraints …\n"],["Gecode::IntEnum::IntEnumOperand","","Gecode/IntEnum/IntEnumOperand.html","","<p>A IntEnumOperand is a enumeration of IntOperand on which the constraints\ndefined in IntEnumConstraintReceiver …\n"],["Gecode::IntVar","","Gecode/IntVar.html","","<p>Describes an integer variable.\n<p>An integer variable can take the value of any integer in its  domain, …\n"],["Gecode::MissingConstraintError","","Gecode/MissingConstraintError.html","","<p>An error signaling that the constraint specified is missing (e.g. one tried\nto negate a constraint, but …\n"],["Gecode::Mixin","","Gecode/Mixin.html","","<p>Mixin contains the base functionality needed to formulate problems.\n<p>Formulating problems\n<p>Problems are formulated …\n"],["Gecode::Model","","Gecode/Model.html","","<p>A convenient class that just includes Gecode::Mixin. Can be useful when you\ndon’t want to create your …\n"],["Gecode::NoSolutionError","","Gecode/NoSolutionError.html","","<p>An exception raised when a search failed because there are no solutions.\n"],["Gecode::Operand","","Gecode/Operand.html","","<p>Describes an operand, something that a constraint can be placed on.\nConstraints are placed by calling …\n"],["Gecode::SearchAbortedError","","Gecode/SearchAbortedError.html","","<p>An exception raised when a search has been aborted due to e.g. hitting the\ntime limit specified when …\n"],["Gecode::SelectedSet","","Gecode/SelectedSet.html","",""],["Gecode::SelectedSet::SelectedSetConstraintReceiver","","Gecode/SelectedSet/SelectedSetConstraintReceiver.html","","<p>SelectedSetConstraintReceiver contains all constraints that can be placed\non a SelectedSetOperand.\n<p>Constraints …\n"],["Gecode::SelectedSet::SelectedSetOperand","","Gecode/SelectedSet/SelectedSetOperand.html","","<p>A SelectedSetOperand is an uncommon operand that results from calling \nSetEnumOperand#[] with a SetOperand …\n"],["Gecode::Set","","Gecode/Set.html","",""],["Gecode::Set::SetConstraintReceiver","","Gecode/Set/SetConstraintReceiver.html","","<p>SetConstraintReceiver contains all constraints that can be placed on a\nSetOperand.\n<p>Constraints are placed …\n"],["Gecode::Set::SetOperand","","Gecode/Set/SetOperand.html","","<p>A SetOperand is a combination of operands on which the constraints defined\nin SetConstraintReceiver can …\n"],["Gecode::SetElements","","Gecode/SetElements.html","",""],["Gecode::SetElements::SetElementsConstraintReceiver","","Gecode/SetElements/SetElementsConstraintReceiver.html","","<p>SetElementsConstraintReceiver contains all constraints that can be placed\non a SetElementsOperand.\n<p>Constraints …\n"],["Gecode::SetElements::SetElementsOperand","","Gecode/SetElements/SetElementsOperand.html","","<p>A SetElementsOperand is an uncommon operand that results from calling \nSetOperand#elements. It facilitates …\n"],["Gecode::SetEnum","","Gecode/SetEnum.html","",""],["Gecode::SetEnum::SetEnumConstraintReceiver","","Gecode/SetEnum/SetEnumConstraintReceiver.html","","<p>SetEnumConstraintReceiver contains all constraints that can be placed on a\nSetEnumOperand.\n<p>Constraints …\n"],["Gecode::SetEnum::SetEnumOperand","","Gecode/SetEnum/SetEnumOperand.html","","<p>A SetEnumOperand is a enumeration of SetOperand on which the constraints\ndefined in SetEnumConstraintReceiver …\n"],["Gecode::SetVar","","Gecode/SetVar.html","","<p>Describes a set variable.\n<p>A set variable’s domain, i.e. possible values that it can take, are\nrepresented …\n"],["Gecode::Util","","Gecode/Util.html","",""],["Gecode::Util::Extensional","","Gecode/Util/Extensional.html","",""],["GecodeRaw","","GecodeRaw.html","",""],["GecodeRaw::Space","","GecodeRaw/Space.html","",""],["Object","","Object.html","",""],["Rust","","Rust.html","",""],["Rust::Bindings","","Rust/Bindings.html","",""],["&","Gecode::Bool::BoolOperand","Gecode/Bool/BoolOperand.html#method-i-26","(bool_op)","<p>Produces a new BoolOperand representing this operand AND\n<code>bool_op</code>.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># (+b1+ and +b2+) or +b3+  ...</span>\n</pre>\n"],["*","Gecode::Bool::BoolOperand","Gecode/Bool/BoolOperand.html#method-i-2A","(fixnum)","<p>Produces an IntOperand representing the value of this boolean operand (0 or\n1) times a constant.\n<p>Examples …\n"],["*","Gecode::Int::IntOperand","Gecode/Int/IntOperand.html#method-i-2A","(int_operand)","<p>Produces a new IntOperand representing this operand times\n<code>int_operand</code>.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># The value of +int_op1+ ...</span>\n</pre>\n"],["+","Gecode::Bool::BoolOperand","Gecode/Bool/BoolOperand.html#method-i-2B","(op2)","<p>Produces an IntOperand representing the value of this boolean operand (0 or\n1) plus <code>op2</code>.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># +bool1+ ...</span>\n</pre>\n"],["+","Gecode::Int::IntOperand","Gecode/Int/IntOperand.html#method-i-2B","(int_operand_or_fixnum)","<p>Produces a new IntOperand representing this operand plus \n<code>int_operand_or_fixnum</code>.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># +int1+ plus ...</span>\n</pre>\n"],["-","Gecode::Bool::BoolOperand","Gecode/Bool/BoolOperand.html#method-i-2D","(op2)","<p>Produces an IntOperand representing the value of this boolean operand (0 or\n1) minus <code>op2</code>.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># +bool1+ ...</span>\n</pre>\n"],["-","Gecode::Int::IntOperand","Gecode/Int/IntOperand.html#method-i-2D","(int_operand_or_fixnum)","<p>Produces a new IntOperand representing this operand minus \n<code>int_operand_or_fixnum</code>.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># +int1+ minus ...</span>\n</pre>\n"],["<","Gecode::Int::IntConstraintReceiver","Gecode/Int/IntConstraintReceiver.html#method-i-3C","(int_operand_or_fixnum, options = {})","<p>Constrains the integer operand to be strictly less than\n<code>int_operand_or_fixnum</code>. #lesser and #lesser_than …\n"],["<","Gecode::SetElements::SetElementsConstraintReceiver","Gecode/SetElements/SetElementsConstraintReceiver.html#method-i-3C","(operand, options = {})","<p>Constrains the set elements to be strictly less than <code>operand</code>\n(either a constant integer or an integer …\n"],["<=","Gecode::Int::IntConstraintReceiver","Gecode/Int/IntConstraintReceiver.html#method-i-3C-3D","(int_operand_or_fixnum, options = {})","<p>Constrains the integer operand to be less than or equal to\n<code>int_operand_or_fixnum</code>. #less_or_equal and …\n"],["<=","Gecode::SetElements::SetElementsConstraintReceiver","Gecode/SetElements/SetElementsConstraintReceiver.html#method-i-3C-3D","(operand, options = {})","<p>Constrains the set elements to be less than or equal to\n<code>operand</code> (either a constant integer or an integer …\n"],["==","Gecode::Bool::BoolConstraintReceiver","Gecode/Bool/BoolConstraintReceiver.html#method-i-3D-3D","(bool_op, options = {})","<p>Constrains the boolean operand to be equal to <code>bool_op</code>.  Any of\n<code>==</code>, <code>equal</code> and <code>equal_to</code> may be used\nfor …\n"],["==","Gecode::Int::IntConstraintReceiver","Gecode/Int/IntConstraintReceiver.html#method-i-3D-3D","(bool, options = {})","<p>Constrains the integer operand to be equal to the specified boolean \noperand. I.e. constrains the integer …\n"],["==","Gecode::Set::SetConstraintReceiver","Gecode/Set/SetConstraintReceiver.html#method-i-3D-3D","(constant_set, options = {})","<p>Constrains the set operand to have a domain equal to\n<code>constant_set</code>.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># +set+ must equal [1,2,5] ...</span>\n</pre>\n"],["==","Gecode::SetElements::SetElementsConstraintReceiver","Gecode/SetElements/SetElementsConstraintReceiver.html#method-i-3D-3D","(operand, options = {})","<p>Constrains the set elements to equal <code>operand</code> (either a\nconstant integer or an integer operand).\n<p>Examples …\n"],[">","Gecode::Int::IntConstraintReceiver","Gecode/Int/IntConstraintReceiver.html#method-i-3E","(int_operand_or_fixnum, options = {})","<p>Constrains the integer operand to be strictly greater than\n<code>int_operand_or_fixnum</code>. #greater and #greater_than …\n"],[">","Gecode::SetElements::SetElementsConstraintReceiver","Gecode/SetElements/SetElementsConstraintReceiver.html#method-i-3E","(operand, options = {})","<p>Constrains the set elements to be strictly greater than\n<code>operand</code> (either a constant integer or an integer …\n"],[">=","Gecode::Int::IntConstraintReceiver","Gecode/Int/IntConstraintReceiver.html#method-i-3E-3D","(int_operand_or_fixnum, options = {})","<p>Constrains the integer operand to be greater than or equal to\n<code>int_operand_or_fixnum</code>. #greater_or_equal …\n"],[">=","Gecode::SetElements::SetElementsConstraintReceiver","Gecode/SetElements/SetElementsConstraintReceiver.html#method-i-3E-3D","(operand, options = {})","<p>Constrains the set elements to be greater than or equal to\n<code>operand</code> (either a constant integer or an integer …\n"],["[]","Gecode::FixnumEnum::FixnumEnumOperand","Gecode/FixnumEnum/FixnumEnumOperand.html#method-c-5B-5D","(*vars)","<p>Produces an IntOperand representing the i:th constant integer in the\nenumeration, where i is the value …\n"],["[]","Gecode::IntEnum::IntEnumOperand","Gecode/IntEnum/IntEnumOperand.html#method-c-5B-5D","(*vars)","<p>Produces an IntOperand representing the i:th integer operand in the\nenumeration, where i is the value …\n"],["[]","Gecode::SetEnum::SetEnumOperand","Gecode/SetEnum/SetEnumOperand.html#method-c-5B-5D","(*vars)","<p>Produces a SetOperand representing the i:th set operand in the enumeration,\nwhere i is the value of the …\n"],["^","Gecode::Bool::BoolOperand","Gecode/Bool/BoolOperand.html#method-i-5E","(bool_op)","<p>Produces a new BoolOperand representing this operand XOR\n<code>bool_op</code>.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># (+b1+ and +b2+) or (+b3+ ...</span>\n</pre>\n"],["abs","Gecode::Int::IntOperand","Gecode/Int/IntOperand.html#method-i-abs","()","<p>Produces an IntOperand representing the absolute value of this  operand.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># The absolute value ...</span>\n</pre>\n"],["any","Gecode::Mixin","Gecode/Mixin.html#method-i-any","(*regexps)","<p>Matches any of the specified <code>regexps</code>.\n"],["at_least_once","Gecode::Mixin","Gecode/Mixin.html#method-i-at_least_once","(regexp)","<p>Matches <code>regexp</code> repeated at least one time (i.e. like ‘+’\nin normal  regexps). Produces the same result …\n"],["at_most_once","Gecode::Mixin","Gecode/Mixin.html#method-i-at_most_once","(regexp)","<p>Matches <code>regexp</code> repeated zero or one time (i.e. like ‘?’ in\nnormal  regexps). Produces the same result …\n"],["at_most_share_one_element","Gecode::SetEnum::SetEnumConstraintReceiver","Gecode/SetEnum/SetEnumConstraintReceiver.html#method-i-at_most_share_one_element","(options = {})","<p>Constrains all pairs of set operands in the enumeration to at most have one\nelement in common and be …\n"],["bool_var","Gecode::Mixin","Gecode/Mixin.html#method-i-bool_var","()","<p>Creates a new boolean variable.\n"],["bool_var_array","Gecode::Mixin","Gecode/Mixin.html#method-i-bool_var_array","(count)","<p>Creates an array containing the specified number of boolean variables.\n"],["bool_var_matrix","Gecode::Mixin","Gecode/Mixin.html#method-i-bool_var_matrix","(row_count, col_count)","<p>Creates a matrix containing the specified number rows and columns of \nboolean variables.\n"],["branch_on","Gecode::Mixin","Gecode/Mixin.html#method-i-branch_on","(variables, options = {})","<p>Specifies which variables that should be branched on (given as an enum of\noperands or as a single operand). …\n"],["cardinality","Gecode::SetVar","Gecode/SetVar.html#method-i-cardinality","()","<p>Returns a range containing the allowed values for the set’s cardinality.\n"],["channel","Gecode::BoolEnum::BoolEnumConstraintReceiver","Gecode/BoolEnum/BoolEnumConstraintReceiver.html#method-i-channel","(integer_operand, options = {})","<p>Constrains this enumeration to “channel” <code>integer_operand</code>.\nThis  constrains the integer operand …\n"],["channel","Gecode::IntEnum::IntEnumConstraintReceiver","Gecode/IntEnum/IntEnumConstraintReceiver.html#method-i-channel","(int_enum, options = {})","<p>Constrains this enumeration to “channel” <code>int_enum</code>. \nChannel constraints are used to give access …\n"],["channel","Gecode::Set::SetConstraintReceiver","Gecode/Set/SetConstraintReceiver.html#method-i-channel","(bool_enum, options = {})","<p>Constrains this set to channel <code>bool_enum</code>. The set is\nconstrained to include value i exactly when the …\n"],["channel","Gecode::SetEnum::SetEnumConstraintReceiver","Gecode/SetEnum/SetEnumConstraintReceiver.html#method-i-channel","(enum, options = {})","<p>Constrains this set enum to channel <code>int_enum_operand</code>. The i:th\nset  in the enumeration of set operands …\n"],["combined_method_missing","Gecode::Mixin","Gecode/Mixin.html#method-i-combined_method_missing","(*args)",""],["complement","Gecode::Set::SetConstraintReceiver","Gecode/Set/SetConstraintReceiver.html#method-i-complement","(constant_set, options = {})","<p>Constrains the set operand to be the complement of\n<code>constant_set</code>.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># +set+ must be the complement ...</span>\n</pre>\n"],["conjunction","Gecode::BoolEnum::BoolEnumOperand","Gecode/BoolEnum/BoolEnumOperand.html#method-i-conjunction","()","<p>Produces a BoolOperand that represents the conjunction (AND) of all boolean\noperands in this enumeration. …\n"],["count","Gecode::IntEnum::IntEnumOperand","Gecode/IntEnum/IntEnumOperand.html#method-i-count","(int_operand_or_fixnum)","<p>Produces a new IntOperand representing the number of times\n<code>int_operand_or_fixnum</code> is present in this enumeration. …\n"],["disjoint","Gecode::SelectedSet::SelectedSetConstraintReceiver","Gecode/SelectedSet/SelectedSetConstraintReceiver.html#method-i-disjoint","(options = {})","<p>Constrains the selected sets to be pairwise disjoint.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># Constrains all sets selected by +set_enum[set]+ ...</span>\n</pre>\n"],["disjoint","Gecode::Set::SetConstraintReceiver","Gecode/Set/SetConstraintReceiver.html#method-i-disjoint","(constant_set, options = {})","<p>Constrains the set operand to be disjoint with <code>constant_set</code>.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># +set+ must be disjoint with [1,2,5] ...</span>\n</pre>\n"],["disjoint_union","Gecode::FixnumEnum::FixnumEnumOperand","Gecode/FixnumEnum/FixnumEnumOperand.html#method-i-disjoint_union","(set_operand)","<p>Produces a new SetOperand representing the disjoint union between this\noperand, interpreted as a constant …\n"],["disjoint_union","Gecode::Set::SetOperand","Gecode/Set/SetOperand.html#method-i-disjoint_union","(set_operand_or_constant_set)","<p>Produces a new SetOperand representing the disjoint union between this\noperand and <code>set_operand_or_constant_set</code> …\n"],["disjoint_union","Gecode::SetEnum::SetEnumOperand","Gecode/SetEnum/SetEnumOperand.html#method-i-disjoint_union","()","<p>Produces a SetOperand representing the disjoint union of all sets  in this\nenumeration.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># The ...</span>\n</pre>\n"],["disjunction","Gecode::BoolEnum::BoolEnumOperand","Gecode/BoolEnum/BoolEnumOperand.html#method-i-disjunction","()","<p>Produces a BoolOperand that represents the disjunction (OR) of all boolean\noperands in this enumeration. …\n"],["distinct","Gecode::IntEnum::IntEnumConstraintReceiver","Gecode/IntEnum/IntEnumConstraintReceiver.html#method-i-distinct","(options = {})","<p>Constrains all integer operands in the enumeration to be distinct\n(different). The constraint can also …\n"],["domain","Gecode::IntVar","Gecode/IntVar.html#method-i-domain","()","<p>Returns an enumeration corresponding to the domain.\n"],["each_solution","Gecode::Mixin","Gecode/Mixin.html#method-i-each_solution","(&block)","<p>Yields each solution that the model has.\n"],["elements","Gecode::Set::SetOperand","Gecode/Set/SetOperand.html#method-i-elements","()","<p>Produces a SetElementsOperand on which relation constraints can be placed\nthat constrain all elements …\n"],["equal","Gecode::IntEnum::IntEnumConstraintReceiver","Gecode/IntEnum/IntEnumConstraintReceiver.html#method-i-equal","(options = {})","<p>Constrains all operands in the enumeration to be equal.  Neither negation\nnor reification is supported. …\n"],["false","Gecode::Bool::BoolConstraintReceiver","Gecode/Bool/BoolConstraintReceiver.html#method-i-false","(options = {})","<p>Constrains the boolean operand to be false.\n<p>Examples \n\n<pre># +b1+ and +b2+ must be false.\n(b1 &amp; b2).must_be.false ...</pre>\n"],["implies","Gecode::Bool::BoolOperand","Gecode/Bool/BoolOperand.html#method-i-implies","(bool_op)","<p>Produces a new BoolOperand representing that this operand implies\n<code>bool_op</code>.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># (+b1+ implies +b2+) ...</span>\n</pre>\n"],["imply","Gecode::Bool::BoolConstraintReceiver","Gecode/Bool/BoolConstraintReceiver.html#method-i-imply","(bool_op, options = {})","<p>Constrains the boolean operand to imply <code>bool_op</code>.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># +b1+ must imply +b2+</span>\n<span class=\"ruby-identifier\">b1</span>.<span class=\"ruby-identifier\">must</span>.<span class=\"ruby-identifier\">imply</span> <span class=\"ruby-identifier\">b2</span>\n\n<span class=\"ruby-comment\"># ...</span>\n</pre>\n"],["in","Gecode::BoolEnum::BoolEnumConstraintReceiver","Gecode/BoolEnum/BoolEnumConstraintReceiver.html#method-i-in","(tuples, options = {})","<p>Constrains all the operands in this enumeration to be equal to one of the\nspecified tuples. Neither negation …\n"],["in","Gecode::Int::IntConstraintReceiver","Gecode/Int/IntConstraintReceiver.html#method-i-in","(domain, options = {})","<p>Creates a domain constraint using the specified domain, specified as an\nenumeration of integers. The …\n"],["in","Gecode::IntEnum::IntEnumConstraintReceiver","Gecode/IntEnum/IntEnumConstraintReceiver.html#method-i-in","(tuples, options = {})","<p>Constrains all the operands in this enumeration to be equal to one of the\nspecified tuples. Neither negation …\n"],["include","Gecode::Set::SetConstraintReceiver","Gecode/Set/SetConstraintReceiver.html#method-i-include","(int_enum)","<p>Constrains this set to include the values of <code>int_enum</code>.\n<p>The constraint has the side effect of sorting the …\n"],["included","Gecode::Mixin","Gecode/Mixin.html#method-c-included","(mod)",""],["int_var","Gecode::Mixin","Gecode/Mixin.html#method-i-int_var","(domain = LARGEST_INT_DOMAIN)","<p>Creates a new integer variable with the specified domain. The domain can\neither be a range, a single …\n"],["int_var_array","Gecode::Mixin","Gecode/Mixin.html#method-i-int_var_array","(count, domain = LARGEST_INT_DOMAIN)","<p>Creates an array containing the specified number of integer variables  with\nthe specified domain. The …\n"],["int_var_matrix","Gecode::Mixin","Gecode/Mixin.html#method-i-int_var_matrix","(row_count, col_count, domain = LARGEST_INT_DOMAIN)","<p>Creates a matrix containing the specified number rows and columns of \ninteger variables with the specified …\n"],["intersection","Gecode::FixnumEnum::FixnumEnumOperand","Gecode/FixnumEnum/FixnumEnumOperand.html#method-i-intersection","(set_operand)","<p>Produces a new SetOperand representing the intersection between this\noperand, interpreted as a constant …\n"],["intersection","Gecode::SelectedSet::SelectedSetOperand","Gecode/SelectedSet/SelectedSetOperand.html#method-i-intersection","(options = {})","<p>Produces a SetOperand representing the selected sets’ intersection. The\noption :with can be used to enumerate …\n"],["intersection","Gecode::Set::SetOperand","Gecode/Set/SetOperand.html#method-i-intersection","(set_operand_or_constant_set)","<p>Produces a new SetOperand representing the intersection between this\noperand and <code>set_operand_or_constant_set</code> …\n"],["intersection","Gecode::SetEnum::SetEnumOperand","Gecode/SetEnum/SetEnumOperand.html#method-i-intersection","()","<p>Produces a SetOperand representing the intersection of all sets in this\nenumeration.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># The intersection ...</span>\n</pre>\n"],["lower_bound","Gecode::SetVar","Gecode/SetVar.html#method-i-lower_bound","()","<p>Gets all the elements located in the greatest lower bound of the set (an \nEnumerable).\n"],["match","Gecode::BoolEnum::BoolEnumConstraintReceiver","Gecode/BoolEnum/BoolEnumConstraintReceiver.html#method-i-match","(regexp, options = {})","<p>Constrains the sequence of operands in this enumeration to match a\nspecified regexp in the boolean domain. …\n"],["match","Gecode::IntEnum::IntEnumConstraintReceiver","Gecode/IntEnum/IntEnumConstraintReceiver.html#method-i-match","(regexp, options = {})","<p>Constrains the sequence of operands in this enumeration to match a\nspecified regexp in the integer domain. …\n"],["max","Gecode::IntEnum::IntEnumOperand","Gecode/IntEnum/IntEnumOperand.html#method-i-max","()","<p>Produces an IntOperand representing the maximum value of the  integer\noperands in this enumeration.\n<p>Examples …\n"],["max","Gecode::Set::SetOperand","Gecode/Set/SetOperand.html#method-i-max","()","<p>Produces an IntOperand representing the maximum of the set.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># The maximum of +set+.</span>\n<span class=\"ruby-identifier\">set</span>.<span class=\"ruby-identifier\">max</span>\n</pre>\n"],["maximize","Gecode","Gecode.html#method-c-maximize","(variable_to_maximize, &block)","<p>Provides a convenient way to construct a model and then find the solution\nthat maximizes a given variable. …\n"],["maximize!","Gecode::Mixin","Gecode/Mixin.html#method-i-maximize-21","(var)","<p>Finds the solution that maximizes a given integer variable. The name of \nthe method that accesses the …\n"],["method_added","Gecode::Mixin","Gecode/Mixin.html#method-c-method_added","(method)",""],["method_missing","Gecode::Mixin","Gecode/Mixin.html#method-i-method_missing","(method, *args)","<p>Wraps method missing to handle #foo_is_a and #foo_is_an .\n<p>“&lt;variable_name&gt;_is_a &lt;variable&gt;” …\n"],["min","Gecode::IntEnum::IntEnumOperand","Gecode/IntEnum/IntEnumOperand.html#method-i-min","()","<p>Produces an IntOperand representing the minimum value of the  integer\noperands in this enumeration.\n<p>Examples …\n"],["min","Gecode::Set::SetOperand","Gecode/Set/SetOperand.html#method-i-min","()","<p>Produces an IntOperand representing the minimum of the set.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># The minimum of +set+.</span>\n<span class=\"ruby-identifier\">set</span>.<span class=\"ruby-identifier\">min</span>\n</pre>\n"],["minimize","Gecode","Gecode.html#method-c-minimize","(variable_to_minimize, &block)","<p>Provides a convenient way to construct a model and then find the solution\nthat minimizes a given variable. …\n"],["minimize!","Gecode::Mixin","Gecode/Mixin.html#method-i-minimize-21","(var)","<p>Finds the solution that minimizes a given integer variable. The name of \nthe method that accesses the …\n"],["minus","Gecode::FixnumEnum::FixnumEnumOperand","Gecode/FixnumEnum/FixnumEnumOperand.html#method-i-minus","(set_operand)","<p>Produces a new SetOperand representing this operand, interpreted as a\nconstant set, minus <code>set_operand</code> …\n"],["minus","Gecode::Set::SetOperand","Gecode/Set/SetOperand.html#method-i-minus","(set_operand_or_constant_set)","<p>Produces a new SetOperand representing this operand minus \n<code>set_operand_or_constant_set</code>.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># +set1+ ...</span>\n</pre>\n"],["model","Gecode::Operand","Gecode/Operand.html#method-i-model","()","<p>Fetches the model that the operand belongs to.\n"],["must","Gecode::Operand","Gecode/Operand.html#method-i-must","()","<p>Specifies that a constraint must hold for the left hand side.\n"],["must_be","Gecode::Operand","Gecode/Operand.html#method-i-must_be","()",""],["must_not","Gecode::Operand","Gecode/Operand.html#method-i-must_not","()","<p>Specifies that the negation of a constraint must hold for the left hand \nside.\n"],["must_not_be","Gecode::Operand","Gecode/Operand.html#method-i-must_not_be","()",""],["new","Gecode::ConstraintReceiver","Gecode/ConstraintReceiver.html#method-c-new","(model, params)","<p>Constructs a new expression with the specified parameters. The  parameters\nshould at least contain the …\n"],["optimize!","Gecode::Mixin","Gecode/Mixin.html#method-i-optimize-21","(&block)","<p>Finds the optimal solution. Optimality is defined by the provided block\nwhich is given two parameters, …\n"],["parse_regexp","Gecode::Util::Extensional","Gecode/Util/Extensional.html#method-i-parse_regexp","(regexp)","<p>Parses a regular expression over the integer domain, returning an instance\nof Gecode::REG .\n<p>Pseudo-BNF …\n"],["pre_arith_mult","Gecode::Int::IntOperand","Gecode/Int/IntOperand.html#method-i-pre_arith_mult","(int_operand)",""],["pre_channel_equals","Gecode::Int::IntConstraintReceiver","Gecode/Int/IntConstraintReceiver.html#method-i-pre_channel_equals","(bool, options = {})",""],["pre_relation_complement","Gecode::Set::SetConstraintReceiver","Gecode/Set/SetConstraintReceiver.html#method-i-pre_relation_complement","(constant_set, options = {})",""],["pre_relation_disjoint","Gecode::Set::SetConstraintReceiver","Gecode/Set/SetConstraintReceiver.html#method-i-pre_relation_disjoint","(constant_set, options = {})",""],["pre_relation_equality","Gecode::Set::SetConstraintReceiver","Gecode/Set/SetConstraintReceiver.html#method-i-pre_relation_equality","(constant_set, options = {})",""],["pre_relation_subset","Gecode::Set::SetConstraintReceiver","Gecode/Set/SetConstraintReceiver.html#method-i-pre_relation_subset","(constant_set, options = {})",""],["pre_relation_superset","Gecode::Set::SetConstraintReceiver","Gecode/Set/SetConstraintReceiver.html#method-i-pre_relation_superset","(constant_set, options = {})",""],["repeat","Gecode::Mixin","Gecode/Mixin.html#method-i-repeat","(regexp, at_least = nil, at_most = nil)","<p>Specifies an integer regexp that matches <code>regexp</code> repeated\nbetween <code>at_least</code> and <code>at_most</code> times (inclusive).\n…\n"],["reset!","Gecode::Mixin","Gecode/Mixin.html#method-i-reset-21","()","<p>Returns to the original state, before any search was made (but  propagation\nmight have been performed). …\n"],["search_stats","Gecode::Mixin","Gecode/Mixin.html#method-i-search_stats","()","<p>Returns search statistics providing various information from Gecode about\nthe search that resulted in …\n"],["set_var","Gecode::Mixin","Gecode/Mixin.html#method-i-set_var","(glb_domain = [], lub_domain = LARGEST_SET_BOUND, cardinality_range = nil)","<p>Creates a set variable with the specified domain for greatest lower bound\nand least upper bound (specified …\n"],["set_var_array","Gecode::Mixin","Gecode/Mixin.html#method-i-set_var_array","(count, glb_domain = [], lub_domain = LARGEST_SET_BOUND, cardinality_range = nil)","<p>Creates an array containing the specified number of set variables. The\nparameters beyond count are the …\n"],["set_var_matrix","Gecode::Mixin","Gecode/Mixin.html#method-i-set_var_matrix","(row_count, col_count, glb_domain = [], lub_domain = LARGEST_SET_BOUND, cardinality_range = nil)","<p>Creates a matrix containing the specified number of rows and columns \nfilled with set variables. The …\n"],["size","Gecode::Set::SetOperand","Gecode/Set/SetOperand.html#method-i-size","()","<p>Produces an IntOperand representing the size of the set.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># The size of +set+.</span>\n<span class=\"ruby-identifier\">set</span>.<span class=\"ruby-identifier\">size</span>\n</pre>\n"],["solution","Gecode::Mixin","Gecode/Mixin.html#method-i-solution","(&block)","<p>Yields the first solution (if any) to the block. If no solution is found\nthen the block is not used. …\n"],["solve","Gecode","Gecode.html#method-c-solve","(&block)","<p>Provides a convenient way to construct a model and then find a solution.\nThe model constructed uses the …\n"],["solve!","Gecode::Mixin","Gecode/Mixin.html#method-i-solve-21","(options = {})","<p>Finds the first solution to the modelled problem and updates the variables\nto that solution. The found …\n"],["sorted","Gecode::IntEnum::IntEnumConstraintReceiver","Gecode/IntEnum/IntEnumConstraintReceiver.html#method-i-sorted","(options = {})","<p>Constrains the elements in this enumeration to be sorted in ascending \norder. The following options can …\n"],["sqrt","Gecode::Int::IntOperand","Gecode/Int/IntOperand.html#method-i-sqrt","()",""],["square_root","Gecode::Int::IntOperand","Gecode/Int/IntOperand.html#method-i-square_root","()","<p>Produces an IntOperand representing the square root of this  operand\nrounded down.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># The square ...</span>\n</pre>\n"],["squared","Gecode::Int::IntOperand","Gecode/Int/IntOperand.html#method-i-squared","()","<p>Produces an IntOperand representing this operand squared.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># The value of +int_op*int_op+.</span>\n<span class=\"ruby-identifier\">int_op</span>.<span class=\"ruby-identifier\">squared</span>\n</pre>\n"],["subset","Gecode::Set::SetConstraintReceiver","Gecode/Set/SetConstraintReceiver.html#method-i-subset","(constant_set, options = {})","<p>Constrains the set operand to be a subset of <code>constant_set</code>.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># +set+ must be a subset of [1,2,5] ...</span>\n</pre>\n"],["sum","Gecode::Set::SetOperand","Gecode/Set/SetOperand.html#method-i-sum","(options = {:weights => weights = Hash.new(1)})","<p>Produces an IntOperand representing the sum of the values in the set. One\nof the following options may …\n"],["superset","Gecode::Set::SetConstraintReceiver","Gecode/Set/SetConstraintReceiver.html#method-i-superset","(constant_set, options = {})","<p>Constrains the set operand to be a superset of <code>constant_set</code>.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># +set+ must be a superset of [1,2,5] ...</span>\n</pre>\n"],["to_bool_var","Gecode::BoolVar","Gecode/BoolVar.html#method-i-to_bool_var","()","<p>Returns the receiver.\n"],["to_int_var","Gecode::IntVar","Gecode/IntVar.html#method-i-to_int_var","()","<p>Returns the receiver.\n"],["to_set_var","Gecode::SetVar","Gecode/SetVar.html#method-i-to_set_var","()","<p>Returns the receiver.\n"],["true","Gecode::Bool::BoolConstraintReceiver","Gecode/Bool/BoolConstraintReceiver.html#method-i-true","(options = {})","<p>Constrains the boolean operand to be true.\n<p>Examples \n\n<pre># +b1+ and +b2+ must be true.\n(b1 &amp; b2).must_be.true ...</pre>\n"],["union","Gecode::FixnumEnum::FixnumEnumOperand","Gecode/FixnumEnum/FixnumEnumOperand.html#method-i-union","(set_operand)","<p>Produces a new SetOperand representing the union between this operand, \ninterpreted as a constant set, …\n"],["union","Gecode::SelectedSet::SelectedSetOperand","Gecode/SelectedSet/SelectedSetOperand.html#method-i-union","()","<p>Produces a SetOperand representing the selected sets’ union.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># The union of all sets selected ...</span>\n</pre>\n"],["union","Gecode::Set::SetOperand","Gecode/Set/SetOperand.html#method-i-union","(set_operand_or_constant_set)","<p>Produces a new SetOperand representing the union between this operand  and\n<code>set_operand_or_constant_set</code> …\n"],["union","Gecode::SetEnum::SetEnumOperand","Gecode/SetEnum/SetEnumOperand.html#method-i-union","()","<p>Produces a SetOperand representing the union of all sets in this\nenumeration.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># The union of ...</span>\n</pre>\n"],["upper_bound","Gecode::SetVar","Gecode/SetVar.html#method-i-upper_bound","()","<p>Gets all the elements located in the least upper bound of the set (an \nEnumerable).\n"],["value","Gecode::BoolVar","Gecode/BoolVar.html#method-i-value","()","<p>Gets the values in the assigned boolean variable (true or false). The \nvariable must be assigned, if …\n"],["value","Gecode::IntVar","Gecode/IntVar.html#method-i-value","()","<p>Gets the value of the assigned integer variable (a Fixnum). The variable\nmust be assigned, if it isn’t …\n"],["value","Gecode::SetVar","Gecode/SetVar.html#method-i-value","()","<p>Gets the values in the assigned set variable (an enumerable).\n"],["wrap_enum","Gecode::Mixin","Gecode/Mixin.html#method-i-wrap_enum","(enum)","<p>Wraps a custom enumerable so that constraints can be specified using it.\nThe argument is altered and …\n"],["|","Gecode::Bool::BoolOperand","Gecode/Bool/BoolOperand.html#method-i-7C","(bool_op)","<p>Produces a new BoolOperand representing this operand OR\n<code>bool_op</code>.\n<p>Examples \n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># +b1+ and +b2+</span>\n<span class=\"ruby-identifier\">b1</span> <span class=\"ruby-operator\">&amp;</span> <span class=\"ruby-identifier\">b2</span>\n</pre>\n"],["CHANGES","","CHANGES.html","","<p>Version 1.1.0\n<p>This release fixes a compilation error when installing the\ngecoder-with-gecode gem using …\n"],["LGPL-LICENSE","","LGPL-LICENSE.html","","\n<pre>                     GNU LESSER GENERAL PUBLIC LICENSE\n                         Version 2.1, February ...</pre>\n"],["README","","README.html","","<p>Gecode/R\n<p>Website: gecoder.org\n<p>Gecode/R is a Ruby interface to the Gecode constraint programming library.\n…\n"],["THANKS","","THANKS.html","","<p>This is a list of people who have contributed to making Gecode/R what it is\ntoday. It is sorted in alphabetical …\n"]],"searchIndex":["gecode","bool","boolconstraintreceiver","booloperand","boolenum","boolenumconstraintreceiver","boolenumoperand","boolvar","constraintreceiver","fixnumenum","fixnumenumoperand","int","intconstraintreceiver","intoperand","intenum","intenumconstraintreceiver","intenumoperand","intvar","missingconstrainterror","mixin","model","nosolutionerror","operand","searchabortederror","selectedset","selectedsetconstraintreceiver","selectedsetoperand","set","setconstraintreceiver","setoperand","setelements","setelementsconstraintreceiver","setelementsoperand","setenum","setenumconstraintreceiver","setenumoperand","setvar","util","extensional","gecoderaw","space","object","rust","bindings","&()","*()","*()","+()","+()","-()","-()","<()","<()","<=()","<=()","==()","==()","==()","==()",">()",">()",">=()",">=()","[]()","[]()","[]()","^()","abs()","any()","at_least_once()","at_most_once()","at_most_share_one_element()","bool_var()","bool_var_array()","bool_var_matrix()","branch_on()","cardinality()","channel()","channel()","channel()","channel()","combined_method_missing()","complement()","conjunction()","count()","disjoint()","disjoint()","disjoint_union()","disjoint_union()","disjoint_union()","disjunction()","distinct()","domain()","each_solution()","elements()","equal()","false()","implies()","imply()","in()","in()","in()","include()","included()","int_var()","int_var_array()","int_var_matrix()","intersection()","intersection()","intersection()","intersection()","lower_bound()","match()","match()","max()","max()","maximize()","maximize!()","method_added()","method_missing()","min()","min()","minimize()","minimize!()","minus()","minus()","model()","must()","must_be()","must_not()","must_not_be()","new()","optimize!()","parse_regexp()","pre_arith_mult()","pre_channel_equals()","pre_relation_complement()","pre_relation_disjoint()","pre_relation_equality()","pre_relation_subset()","pre_relation_superset()","repeat()","reset!()","search_stats()","set_var()","set_var_array()","set_var_matrix()","size()","solution()","solve()","solve!()","sorted()","sqrt()","square_root()","squared()","subset()","sum()","superset()","to_bool_var()","to_int_var()","to_set_var()","true()","union()","union()","union()","union()","upper_bound()","value()","value()","value()","wrap_enum()","|()","changes","lgpl-license","readme","thanks"],"longSearchIndex":["gecode","gecode::bool","gecode::bool::boolconstraintreceiver","gecode::bool::booloperand","gecode::boolenum","gecode::boolenum::boolenumconstraintreceiver","gecode::boolenum::boolenumoperand","gecode::boolvar","gecode::constraintreceiver","gecode::fixnumenum","gecode::fixnumenum::fixnumenumoperand","gecode::int","gecode::int::intconstraintreceiver","gecode::int::intoperand","gecode::intenum","gecode::intenum::intenumconstraintreceiver","gecode::intenum::intenumoperand","gecode::intvar","gecode::missingconstrainterror","gecode::mixin","gecode::model","gecode::nosolutionerror","gecode::operand","gecode::searchabortederror","gecode::selectedset","gecode::selectedset::selectedsetconstraintreceiver","gecode::selectedset::selectedsetoperand","gecode::set","gecode::set::setconstraintreceiver","gecode::set::setoperand","gecode::setelements","gecode::setelements::setelementsconstraintreceiver","gecode::setelements::setelementsoperand","gecode::setenum","gecode::setenum::setenumconstraintreceiver","gecode::setenum::setenumoperand","gecode::setvar","gecode::util","gecode::util::extensional","gecoderaw","gecoderaw::space","object","rust","rust::bindings","gecode::bool::booloperand#&()","gecode::bool::booloperand#*()","gecode::int::intoperand#*()","gecode::bool::booloperand#+()","gecode::int::intoperand#+()","gecode::bool::booloperand#-()","gecode::int::intoperand#-()","gecode::int::intconstraintreceiver#<()","gecode::setelements::setelementsconstraintreceiver#<()","gecode::int::intconstraintreceiver#<=()","gecode::setelements::setelementsconstraintreceiver#<=()","gecode::bool::boolconstraintreceiver#==()","gecode::int::intconstraintreceiver#==()","gecode::set::setconstraintreceiver#==()","gecode::setelements::setelementsconstraintreceiver#==()","gecode::int::intconstraintreceiver#>()","gecode::setelements::setelementsconstraintreceiver#>()","gecode::int::intconstraintreceiver#>=()","gecode::setelements::setelementsconstraintreceiver#>=()","gecode::fixnumenum::fixnumenumoperand::[]()","gecode::intenum::intenumoperand::[]()","gecode::setenum::setenumoperand::[]()","gecode::bool::booloperand#^()","gecode::int::intoperand#abs()","gecode::mixin#any()","gecode::mixin#at_least_once()","gecode::mixin#at_most_once()","gecode::setenum::setenumconstraintreceiver#at_most_share_one_element()","gecode::mixin#bool_var()","gecode::mixin#bool_var_array()","gecode::mixin#bool_var_matrix()","gecode::mixin#branch_on()","gecode::setvar#cardinality()","gecode::boolenum::boolenumconstraintreceiver#channel()","gecode::intenum::intenumconstraintreceiver#channel()","gecode::set::setconstraintreceiver#channel()","gecode::setenum::setenumconstraintreceiver#channel()","gecode::mixin#combined_method_missing()","gecode::set::setconstraintreceiver#complement()","gecode::boolenum::boolenumoperand#conjunction()","gecode::intenum::intenumoperand#count()","gecode::selectedset::selectedsetconstraintreceiver#disjoint()","gecode::set::setconstraintreceiver#disjoint()","gecode::fixnumenum::fixnumenumoperand#disjoint_union()","gecode::set::setoperand#disjoint_union()","gecode::setenum::setenumoperand#disjoint_union()","gecode::boolenum::boolenumoperand#disjunction()","gecode::intenum::intenumconstraintreceiver#distinct()","gecode::intvar#domain()","gecode::mixin#each_solution()","gecode::set::setoperand#elements()","gecode::intenum::intenumconstraintreceiver#equal()","gecode::bool::boolconstraintreceiver#false()","gecode::bool::booloperand#implies()","gecode::bool::boolconstraintreceiver#imply()","gecode::boolenum::boolenumconstraintreceiver#in()","gecode::int::intconstraintreceiver#in()","gecode::intenum::intenumconstraintreceiver#in()","gecode::set::setconstraintreceiver#include()","gecode::mixin::included()","gecode::mixin#int_var()","gecode::mixin#int_var_array()","gecode::mixin#int_var_matrix()","gecode::fixnumenum::fixnumenumoperand#intersection()","gecode::selectedset::selectedsetoperand#intersection()","gecode::set::setoperand#intersection()","gecode::setenum::setenumoperand#intersection()","gecode::setvar#lower_bound()","gecode::boolenum::boolenumconstraintreceiver#match()","gecode::intenum::intenumconstraintreceiver#match()","gecode::intenum::intenumoperand#max()","gecode::set::setoperand#max()","gecode::maximize()","gecode::mixin#maximize!()","gecode::mixin::method_added()","gecode::mixin#method_missing()","gecode::intenum::intenumoperand#min()","gecode::set::setoperand#min()","gecode::minimize()","gecode::mixin#minimize!()","gecode::fixnumenum::fixnumenumoperand#minus()","gecode::set::setoperand#minus()","gecode::operand#model()","gecode::operand#must()","gecode::operand#must_be()","gecode::operand#must_not()","gecode::operand#must_not_be()","gecode::constraintreceiver::new()","gecode::mixin#optimize!()","gecode::util::extensional#parse_regexp()","gecode::int::intoperand#pre_arith_mult()","gecode::int::intconstraintreceiver#pre_channel_equals()","gecode::set::setconstraintreceiver#pre_relation_complement()","gecode::set::setconstraintreceiver#pre_relation_disjoint()","gecode::set::setconstraintreceiver#pre_relation_equality()","gecode::set::setconstraintreceiver#pre_relation_subset()","gecode::set::setconstraintreceiver#pre_relation_superset()","gecode::mixin#repeat()","gecode::mixin#reset!()","gecode::mixin#search_stats()","gecode::mixin#set_var()","gecode::mixin#set_var_array()","gecode::mixin#set_var_matrix()","gecode::set::setoperand#size()","gecode::mixin#solution()","gecode::solve()","gecode::mixin#solve!()","gecode::intenum::intenumconstraintreceiver#sorted()","gecode::int::intoperand#sqrt()","gecode::int::intoperand#square_root()","gecode::int::intoperand#squared()","gecode::set::setconstraintreceiver#subset()","gecode::set::setoperand#sum()","gecode::set::setconstraintreceiver#superset()","gecode::boolvar#to_bool_var()","gecode::intvar#to_int_var()","gecode::setvar#to_set_var()","gecode::bool::boolconstraintreceiver#true()","gecode::fixnumenum::fixnumenumoperand#union()","gecode::selectedset::selectedsetoperand#union()","gecode::set::setoperand#union()","gecode::setenum::setenumoperand#union()","gecode::setvar#upper_bound()","gecode::boolvar#value()","gecode::intvar#value()","gecode::setvar#value()","gecode::mixin#wrap_enum()","gecode::bool::booloperand#|()","","","",""]}}