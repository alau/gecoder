---
title: Set Constraints
long_title: Set constraints supported by Gecode/R
inMenu: true
description: The different set constraints available in Gecode/R for use when modelling in Ruby.
---

h2. Set constraints

In the examples @constant_set@ represents a constant set, @set@ represents a 
single set variable and @sets@ represents an enumeration of set variables.

A constant set can be represented with instances of the following classes:
* Fixnum - represents a singleton set.
* Range - represents a set containing all elements in the range. This represents the set more efficiently than when another enumeration with the same elements are used.
* Enumeration of integers - represents a set containing the enumeration's elements.

h3. Domain

Domain constraints are used to specify relations with constant sets.

<ruby>
set.must_not == constant_set
</ruby>

The following relations are supported (the aliases of each relation are also 
listed).

* @==@, @equal@, @equal_to@
* @subset@, @subset_of@
* @superset@, @superset_of@
* @disjoint@, @disjoint_with@
* @complement@, @complement_of@

h3. Relation

Relation constraints are used to specify relations with other sets.

<ruby>
set.must_be.superset_of another_set
</ruby>

The constraint supports the same relations as the domain constraint. The 
relation constraints also includes a constraint used to specify integer 
relations for each element of a set. If we for instance want the elements of a 
set to be bounded by an int var @upper_bound@ we could write the following.

<ruby>
set.elements.must <= upper_bound
</ruby>

Constant integers instead of the integer variable are also supported. Note that
this constraint is not reifiable.

h3. Cardinality

Cardinality constraints constrain the size of the set. Constraining the size of 
@set@ to be within the range @1..2@ can be expressed as follows.

<ruby>
set.size.must_be.in 1..2
</ruby>

Similarly one can constrain the cardinality to be less than an integer variable
as follows.

<ruby>
set.size.must <= number
</ruby>

Everything that's normally supported by single integer variables followed by 
@must*@ is supported after @set.size.must*@ too.

h3. Channel

This is similar to the channel constraint for integer variable enumeration, but
instead of having two integer enums we have one integer and one set enumeration.
If we revisit the integer constraint's channel example we can replace the 
position variables with several sets that are constructed so that set i contains
a position iff element i is located at that position.

<ruby>
position_sets.must.channel elements
</ruby>
or
<ruby>
elements.must.channel position_sets
</ruby>

This allows us to post constraints on @position_sets@ and have them affect
@elements@ (gaining another viewpoint). Neither negation nor reification is 
supported by the constraint.

h3. Min and max

The min and max constraints constrain the minimum and maximum of a set. The 
following constraints connects the integer variables @min@ and @max@ to the 
min and max of @set@.

<ruby>
set.min.must == min
set.max.must == max
</ruby>

Constants can also be used (instead of e.g. @min@ in the example). Everything
that's normally supported by single integer variables followed by @must*@ is 
supported after @set.min.must*@ too (e.g. comparison methods).

h3. Sum

The following constrains the sum of @set@ to be in the range @-10..-1@.

<ruby>
set.sum.must_be.in?(-10..-1)
</ruby>

The weighted sum can also be constrained. The weights are given as a hash that
maps elements in the set to their respective weight. If the hash maps a value 
to nil then it's removed from the set's upper bound. The following constrains
@odd_sum@ to be the sum of all odd numbers in @set@.

<ruby>
weights = Hash.new{ |hash, key| hash[key] = key % 2 }
set.sum(:weights => weights).must == odd_sum
</ruby>

Values can also be substituted instead of weighed by using @:substitutions@ 
instead of @:weigths@. The following sums the contents of an fixnum array 
@array@ which has it's indices in a set variable called @indices@.

<ruby>
substitutions = Hash[*(0...array.size).zip(array).flatten]
indices.sum(:substitutions => substitutions).must == array_sum
</ruby>

Everything that's normally supported by single integer variables followed by 
@must*@ is supported after a set sum.

h3. Include

The following can be used to constrain @set@ to include a number of integer 
variables located in the integer variable enum @numbers@.

<ruby>
set.must.include numbers
</ruby>

It has the side effect of sorting the integer variables in a non-descending 
order. The constraint does not support reification nor negation.

h3. Distinct

There exists a distinct constraint for set variables, it's similar to the one 
for integer variables.

<ruby>
sets.must_be.distinct(:size => 17)
</ruby>

The "option" @:size@ above is not optional, it has to be specified when using
the distinct constraint with sets. There's a similar constraint that constrains
the sets to at most share one element.

<ruby>
sets.must.at_most_share_one_element(:size => 17)
</ruby>

Neither of the constraints support reification nor negation.